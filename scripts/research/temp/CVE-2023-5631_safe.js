const express = require('express');
const DOMPurify = require('isomorphic-dompurify');
const app = express();

app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// Simulación muy simplificada de almacenamiento de correos
const messages = []; // [{ from, subject, bodyHtmlSafe }]

// Configuración opcional de DOMPurify para entorno servidor
// (en Node, isomorphic-dompurify usa JSDOM internamente)

// Endpoint que "recibe" un correo y lo almacena de forma segura
app.post('/api/messages', (req, res) => {
  const { from, subject, bodyHtml } = req.body;

  // MITIGACIÓN: sanitizar el HTML antes de almacenarlo
  // Se eliminan <script>, on* handlers, URLs peligrosas, etc.
  const sanitizedBody = DOMPurify.sanitize(bodyHtml, {
    ALLOWED_TAGS: [
      'b', 'i', 'u', 'strong', 'em', 'p', 'br', 'ul', 'ol', 'li',
      'a', 'span', 'div', 'img'
    ],
    ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'style']
  });

  messages.push({ from, subject, bodyHtmlSafe: sanitizedBody });

  res.json({ status: 'stored' });
});

// Endpoint que muestra el correo en una vista HTML de forma segura
app.get('/message/:id', (req, res) => {
  const id = parseInt(req.params.id, 10);
  const msg = messages[id];

  if (!msg) {
    return res.status(404).send('Message not found');
  }

  // Se utiliza únicamente el HTML previamente sanitizado
  const html = `
    <!doctype html>
    <html>
      <head>
        <meta charset="utf-8" />
        <title>Mensaje</title>
        <!-- Cabeceras recomendadas para mitigar XSS -->
        <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'; object-src 'none'; base-uri 'self';" />
      </head>
      <body>
        <h1>Asunto: ${escapeHtml(msg.subject)}</h1>
        <h2>De: ${escapeHtml(msg.from)}</h2>
        <hr />
        <div id="message-body">
          ${msg.bodyHtmlSafe}
        </div>
      </body>
    </html>
  `;

  res.setHeader('Content-Type', 'text/html; charset=utf-8');
  res.send(html);
});

// Función auxiliar para escapar texto que NO debe interpretarse como HTML
function escapeHtml(str = '') {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

app.listen(3001, () => {
  console.log('Servidor seguro escuchando en http://localhost:3001');
});
