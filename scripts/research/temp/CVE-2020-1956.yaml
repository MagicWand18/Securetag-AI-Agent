rules:
  - id: synthetic-cve20201956
    languages: [javascript, typescript]
    severity: ERROR
    message: >
      Posible inyección de comandos del sistema operativo (OS Command Injection)
      relacionada con CVE-2020-1956 / APIs tipo "Kylin-like". Se está construyendo
      un comando de shell con datos controlados por el usuario (por ejemplo,
      parámetros de una petición HTTP) y pasándolo a child_process.exec/execSync
      sin sanitización robusta. Un atacante puede inyectar comandos arbitrarios
      (por ejemplo, `"; rm -rf /"`), lo que permite ejecución remota de código
      (RCE) con los privilegios del proceso del servidor.
    metadata:
      cve: "CVE-2020-1956"
      source: "CISA_KEV"
      category: "security"
      technology:
        - nodejs
        - express
      owasp:
        - A01:2021-Broken Access Control
        - A03:2021-Injection
      references:
        - https://nvd.nist.gov/vuln/detail/CVE-2020-1956
        - https://semgrep.dev/docs/writing-rules/pattern-syntax/
    patterns:
      # 1) Encontrar uso de exec/execSync con un comando construido dinámicamente
      - pattern-either:
          - pattern: |
              const { exec } = require('child_process');
              ...
              exec($CMD, ...);
          - pattern: |
              const { execSync } = require('child_process');
              ...
              execSync($CMD, ...);
          - pattern: |
              const child_process = require('child_process');
              ...
              child_process.exec($CMD, ...);
          - pattern: |
              const child_process = require('child_process');
              ...
              child_process.execSync($CMD, ...);

      # 2) El comando se construye con concatenación o template literal
      - pattern-either:
          - pattern: |
              const $CMD = $A + $B;
          - pattern: |
              let $CMD = $A + $B;
          - pattern: |
              var $CMD = $A + $B;
          - pattern: |
              const $CMD = `$...${$X}$...`;
          - pattern: |
              let $CMD = `$...${$X}$...`;
          - pattern: |
              var $CMD = `$...${$X}$...`;

      # 3) El comando incluye datos provenientes de la petición HTTP (req.body, req.query, req.params)
      - pattern-either:
          - pattern: |
              const { ..., $V, ... } = req.body;
          - pattern: |
              const { ..., $V, ... } = req.query;
          - pattern: |
              const { ..., $V, ... } = req.params;
          - pattern: |
              let $V = req.body.$FIELD;
          - pattern: |
              let $V = req.query.$FIELD;
          - pattern: |
              let $V = req.params.$FIELD;

      # 4) Asegurar que la variable de la petición fluye hacia el comando
      - pattern: |
          ...
          $V = ...;
          ...
          $CMD = ... $V ...;
          ...
          exec($CMD, ...);

    fix: >
      Evita construir comandos de shell con datos controlados por el usuario.
      Usa APIs seguras como child_process.execFile/execFileSync con argumentos
      separados, valida estrictamente los parámetros permitidos (listas blancas)
      y/o elimina completamente la necesidad de ejecutar comandos del sistema
      operativo desde la ruta HTTP.