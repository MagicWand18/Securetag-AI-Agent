const express = require('express');
const app = express();
const he = require('he'); // npm install he

// Versión segura: se escapa el contenido y se validan los esquemas de URL

app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// Función para validar que la URL tenga un esquema permitido (http/https/mailto)
function sanitizeUrl(raw) {
  try {
    const trimmed = raw.trim();

    // Rechazar esquemas peligrosos como javascript:, data:, vbscript:, etc.
    const lower = trimmed.toLowerCase();
    if (lower.startsWith('javascript:') ||
        lower.startsWith('data:') ||
        lower.startsWith('vbscript:')) {
      return null;
    }

    const url = new URL(trimmed, 'http://example.com'); // base para URLs relativas

    if (!['http:', 'https:', 'mailto:'].includes(url.protocol)) {
      return null;
    }

    return trimmed;
  } catch (e) {
    return null;
  }
}

app.post('/render-email', (req, res) => {
  const body = req.body.body || '';

  // Escapar todo el texto primero para evitar inyección de HTML/JS
  const escapedBody = he.encode(body, { useNamedReferences: true });

  // Detectar URLs en el texto ESCAPADO (coincidiendo con la versión sin escapar)
  const urlRegex = /(https?:\/\/[^\s]+)/g;

  // Para poder hacer el reemplazo de forma segura, trabajamos sobre el texto original
  // pero generando solo HTML escapado y atributos validados.
  const htmlBody = body.replace(urlRegex, (match) => {
    const safeHref = sanitizeUrl(match);
    const safeText = he.encode(match, { useNamedReferences: true });

    if (!safeHref) {
      // Si la URL no es válida/segura, se muestra como texto plano
      return safeText;
    }

    // Escapar el valor del atributo href
    const safeHrefAttr = he.encode(safeHref, { useNamedReferences: true });
    return `<a href="${safeHrefAttr}">${safeText}</a>`;
  });

  // Escapar el resto del contenido que no fue procesado como enlace
  const fullyEscaped = he.encode(htmlBody, { useNamedReferences: true });

  // Como ya hemos escapado todo, ahora podemos volver a "inyectar" los enlaces seguros.
  // Para simplificar, repetimos el proceso pero partiendo del texto original y solo
  // generando enlaces donde haya URLs válidas.
  const safeHtmlBody = body.split(/(https?:\/\/[^\s]+)/g).map((segment) => {
    if (urlRegex.test(segment)) {
      urlRegex.lastIndex = 0; // reset
      const safeHref = sanitizeUrl(segment);
      const safeText = he.encode(segment, { useNamedReferences: true });
      if (!safeHref) return safeText;
      const safeHrefAttr = he.encode(safeHref, { useNamedReferences: true });
      return `<a href="${safeHrefAttr}">${safeText}</a>`;
    }
    return he.encode(segment, { useNamedReferences: true });
  }).join('');

  const html = `
    <html>
      <head><title>Email</title></head>
      <body>
        <h1>Mensaje recibido</h1>
        <div>${safeHtmlBody}</div>
      </body>
    </html>
  `;

  res.setHeader('Content-Type', 'text/html; charset=utf-8');
  res.send(html);
});

app.listen(3001, () => {
  console.log('Servidor seguro escuchando en http://localhost:3001');
});
