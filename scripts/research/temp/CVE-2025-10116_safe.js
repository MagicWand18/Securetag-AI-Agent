const express = require('express');
const fileUpload = require('express-fileupload');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');

const app = express();
app.use(fileUpload({
  limits: {
    fileSize: 5 * 1024 * 1024 // 5 MB
  },
  abortOnLimit: true
}));

// Directorio de subida NO servible directamente por el servidor web
const UPLOAD_DIR = path.join(__dirname, 'protected_uploads');
if (!fs.existsSync(UPLOAD_DIR)) {
  fs.mkdirSync(UPLOAD_DIR, { recursive: true });
}

// Lista blanca de extensiones permitidas (por ejemplo, solo imágenes)
const ALLOWED_EXTENSIONS = new Set(['.jpg', '.jpeg', '.png', '.gif', '.pdf']);

// Validación simple de tipo MIME esperado
const ALLOWED_MIME_TYPES = new Set([
  'image/jpeg',
  'image/png',
  'image/gif',
  'application/pdf'
]);

app.post('/admin/file_upload', (req, res) => {
  if (!req.files || !req.files.file) {
    return res.status(400).send('No file uploaded');
  }

  const file = req.files.file;

  // Validar extensión
  const ext = path.extname(file.name).toLowerCase();
  if (!ALLOWED_EXTENSIONS.has(ext)) {
    return res.status(400).send('File type not allowed');
  }

  // Validar MIME type (no es perfecto, pero añade una capa)
  if (!ALLOWED_MIME_TYPES.has(file.mimetype)) {
    return res.status(400).send('MIME type not allowed');
  }

  // Generar un nombre de archivo seguro y aleatorio, sin usar el nombre original
  const safeName = crypto.randomBytes(16).toString('hex') + ext;
  const uploadPath = path.join(UPLOAD_DIR, safeName);

  file.mv(uploadPath, (err) => {
    if (err) {
      return res.status(500).send('Error uploading file');
    }

    // No se expone la ruta real del sistema de archivos
    // Se podría guardar en BD un identificador y metadatos para acceso controlado
    res.json({
      message: 'File uploaded successfully',
      fileId: safeName
    });
  });
});

// Ejemplo de descarga controlada (no se sirve directamente el directorio)
app.get('/admin/file/:id', (req, res) => {
  const fileId = req.params.id;

  // Validar formato del identificador (solo hex + extensión conocida)
  const ext = path.extname(fileId).toLowerCase();
  if (!ALLOWED_EXTENSIONS.has(ext) || !/^[0-9a-f]+\.[a-z0-9]+$/i.test(fileId)) {
    return res.status(400).send('Invalid file identifier');
  }

  const filePath = path.join(UPLOAD_DIR, fileId);

  fs.access(filePath, fs.constants.R_OK, (err) => {
    if (err) {
      return res.status(404).send('File not found');
    }
    // Se fuerza descarga, no ejecución en el navegador
    res.download(filePath);
  });
});

app.listen(3000, () => {
  console.log('Server listening on port 3000');
});
