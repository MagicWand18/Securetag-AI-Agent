const express = require('express');
const fs = require('fs');
const path = require('path');
const http = require('http');
const crypto = require('crypto');

// PMS configurado (idealmente validado/firmado, no arbitrario)
const pmsBaseUrl = 'http://trusted-pms.local:32400';

const app = express();

// Lista blanca de extensiones/formats permitidos
const ALLOWED_FORMATS = new Set(['jpg', 'jpeg', 'png', 'webp']);

// Directorio de caché restringido
const imagesDir = path.join(__dirname, 'images_cache');
if (!fs.existsSync(imagesDir)) {
  fs.mkdirSync(imagesDir, { recursive: true });
}

// Normaliza y valida el "formato" para evitar path traversal y escritura arbitraria
function sanitizeImgFormat(rawFormat) {
  if (!rawFormat) return null;

  // Quitar posibles puntos iniciales o rutas
  const base = path.basename(rawFormat).toLowerCase();

  // Permitir solo caracteres seguros (letras, números y punto)
  if (!/^[a-z0-9.]+$/.test(base)) {
    return null;
  }

  // Extraer extensión real
  const ext = base.split('.').pop();
  if (!ALLOWED_FORMATS.has(ext)) {
    return null;
  }

  // Devolver solo la extensión normalizada
  return ext;
}

app.get('/pms_image_proxy', (req, res) => {
  const imgUrl = req.query.img;
  const rawImgFormat = req.query.img_format;

  if (!imgUrl || !rawImgFormat) {
    return res.status(400).send('Missing img or img_format');
  }

  const imgFormat = sanitizeImgFormat(rawImgFormat);
  if (!imgFormat) {
    return res.status(400).send('Invalid img_format');
  }

  // Hash de metadatos para nombre de archivo, pero sin permitir que el usuario
  // controle el final de la ruta más allá de una extensión segura
  const meta = `${imgUrl}`;
  const hash = crypto.createHash('md5').update(meta).digest('hex');

  // Ruta segura: hash + extensión controlada por lista blanca
  const fileName = `${hash}.${imgFormat}`;
  const filePath = path.join(imagesDir, fileName);

  // Verificación extra: asegurar que filePath permanezca dentro de imagesDir
  const resolved = path.resolve(filePath);
  if (!resolved.startsWith(path.resolve(imagesDir) + path.sep)) {
    return res.status(400).send('Invalid path');
  }

  fs.access(resolved, fs.constants.F_OK, (err) => {
    if (!err) {
      return fs.createReadStream(resolved).pipe(res);
    }

    // Construir URL hacia PMS confiable (no controlado por el usuario)
    let pmsUrl;
    try {
      pmsUrl = new URL(imgUrl, pmsBaseUrl);
    } catch (e) {
      return res.status(400).send('Invalid img URL');
    }

    http.get(pmsUrl, (pmsRes) => {
      if (pmsRes.statusCode !== 200) {
        return res.status(502).send('Failed to fetch image from PMS');
      }

      // Solo permitimos tipos de contenido de imagen
      const contentType = pmsRes.headers['content-type'] || '';
      if (!/^image\//i.test(contentType)) {
        pmsRes.resume(); // descartar
        return res.status(415).send('Unsupported content type from PMS');
      }

      const writeStream = fs.createWriteStream(resolved, { flags: 'wx' });
      pmsRes.pipe(writeStream);

      writeStream.on('finish', () => {
        fs.createReadStream(resolved).pipe(res);
      });

      writeStream.on('error', (e) => {
        if (e.code === 'EEXIST') {
          return fs.createReadStream(resolved).pipe(res);
        }
        res.status(500).send('Error writing file');
      });
    }).on('error', () => {
      res.status(502).send('Error contacting PMS');
    });
  });
});

// Versión segura del "script notification agent":
// en lugar de ejecutar rutas arbitrarias, se usa una lista blanca de scripts
const ALLOWED_SCRIPTS = new Map([
  ['notify_new_media', path.join(__dirname, 'scripts', 'notify_new_media.py')],
  ['cleanup_cache', path.join(__dirname, 'scripts', 'cleanup_cache.py')]
]);

app.post('/run_script', express.json(), (req, res) => {
  const scriptId = req.body.script_id; // identificador lógico, no ruta
  const scriptPath = ALLOWED_SCRIPTS.get(scriptId);

  if (!scriptPath) {
    return res.status(400).send('Unknown script_id');
  }

  const resolved = path.resolve(scriptPath);
  const scriptsDir = path.resolve(path.join(__dirname, 'scripts'));
  if (!resolved.startsWith(scriptsDir + path.sep)) {
    return res.status(400).send('Invalid script path');
  }

  const { spawn } = require('child_process');
  const child = spawn('python3', [resolved], { stdio: ['ignore', 'pipe', 'pipe'] });

  let output = '';
  child.stdout.on('data', (data) => (output += data.toString()));
  child.stderr.on('data', (data) => (output += data.toString()));

  child.on('close', (code) => {
    res.json({ exitCode: code, output });
  });
});

app.listen(3001, () => {
  console.log('Safe server listening on port 3001');
});
