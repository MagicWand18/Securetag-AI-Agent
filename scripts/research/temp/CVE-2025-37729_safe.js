const express = require('express');
const bodyParser = require('body-parser');
const { Jinjava } = require('jinjava-js'); // Supongamos un binding JS de Jinjava

const app = express();
app.use(bodyParser.json());

// Instancia del motor de plantillas Jinjava
const jinjava = new Jinjava();

// Contexto SEGURO: solo datos no sensibles y sin funciones que permitan ejecutar comandos
const publicTemplateContext = {
  // Solo información no sensible que se quiere exponer a plantillas
  ui: {
    appName: 'ECE Admin Portal',
    supportEmail: 'support@example.com'
  },
  // Datos de usuario limitados (ejemplo)
  user: (req) => ({
    id: req.headers['x-user-id'] || 'unknown',
    role: req.headers['x-role'] || 'viewer'
  })
};

// Lista blanca de variables permitidas en plantillas
const ALLOWED_VARIABLES = ['ui', 'user'];

// Función para construir un contexto restringido por petición
function buildSafeContext(req) {
  return {
    ui: publicTemplateContext.ui,
    user: publicTemplateContext.user(req)
  };
}

// (Opcional) Sencillo filtro para bloquear construcciones peligrosas en la plantilla
// NOTA: En un entorno real, usar capacidades de sandboxing del motor o configuración
// de seguridad específica de Jinjava para deshabilitar expresiones peligrosas.
function isTemplateSafe(template) {
  const forbiddenPatterns = [
    /\{\%\s*set\s+/i,          // Evitar set de variables que puedan encadenar lógica compleja
    /\|\s*attr\s*\(/i,         // Evitar acceso dinámico a atributos
    /\|\s*tojson\s*/i,         // Ejemplo de filtros que podrían exfiltrar estructuras completas
    /ece\s*\./i,               // Cualquier referencia a un objeto ece hipotético
    /internalConfig/i,          // Bloquear referencias a nombres de variables sensibles
    /env\s*\(/i                // Evitar acceso a entorno si el motor lo permite
  ];

  return !forbiddenPatterns.some((re) => re.test(template));
}

// Ruta segura: solo permite plantillas sobre un contexto limitado y con filtrado básico
app.post('/admin/render-template', async (req, res) => {
  try {
    const { template } = req.body;

    const isAdmin = req.headers['x-admin'] === 'true';
    if (!isAdmin) {
      return res.status(403).json({ error: 'Forbidden' });
    }

    if (typeof template !== 'string' || template.length > 2000) {
      return res.status(400).json({ error: 'Invalid template' });
    }

    // Validar que la plantilla no contenga construcciones peligrosas
    if (!isTemplateSafe(template)) {
      return res.status(400).json({ error: 'Template contains forbidden constructs' });
    }

    // Construir un contexto restringido por petición
    const safeContext = buildSafeContext(req);

    // RENDERIZADO SEGURO:
    //  - No se exponen variables sensibles (internalConfig, tokens, claves, etc.)
    //  - No se exponen funciones que permitan ejecutar comandos (ece.runAdminCommand, etc.)
    //  - Se aplica un filtro básico de plantilla para bloquear patrones peligrosos
    const rendered = await jinjava.render(template, safeContext);

    res.json({ rendered });
  } catch (err) {
    console.error('Error rendering template (safe):', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Ejemplo de plantilla permitida:
// {
//   "template": "Bienvenido {{ user.id }} a {{ ui.appName }}.\n" +
//               "Si necesitas ayuda, escribe a {{ ui.supportEmail }}."
// }

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Safe server listening on port ${PORT}`);
});
