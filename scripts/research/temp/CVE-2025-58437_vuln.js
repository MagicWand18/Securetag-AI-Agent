const express = require('express');
const fs = require('fs');
const app = express();
app.use(express.json());

// Simulación de almacenamiento en memoria de workspaces y sesiones
const workspaces = new Map();
// Estructura: { id, ownerUserId, sessionToken, isPrebuilt, claimedBy }

// Función insegura que genera un token de sesión
function generateSessionToken(userId, workspaceId) {
  // Token predecible y sin expiración
  return `sess_${userId}_${workspaceId}_${Date.now()}`;
}

// Endpoint que crea un workspace preconstruido (prebuilt)
app.post('/prebuilds', (req, res) => {
  const workspaceId = `ws_${Date.now()}`;
  const prebuildUserId = 'prebuilds-system-user';

  // Se genera automáticamente un token de sesión para el usuario "prebuilds-system-user"
  const sessionToken = generateSessionToken(prebuildUserId, workspaceId);

  const ws = {
    id: workspaceId,
    ownerUserId: prebuildUserId,
    sessionToken, // <-- Token de sesión del usuario de prebuilds
    isPrebuilt: true,
    claimedBy: null
  };

  workspaces.set(workspaceId, ws);

  // VULNERABILIDAD: el token de sesión se persiste en un archivo de plantilla
  // simulando coder_workspace_owner.session_token expuesto en plantillas Terraform
  const templateData = {
    workspace_id: workspaceId,
    coder_workspace_owner: {
      id: prebuildUserId,
      session_token: sessionToken // <-- Token persistido y reutilizable
    }
  };

  fs.writeFileSync(`./templates/${workspaceId}.json`, JSON.stringify(templateData, null, 2));

  res.json({
    message: 'Prebuilt workspace created',
    workspaceId,
    // Se devuelve también el token del usuario de prebuilds (aún peor)
    prebuildSessionToken: sessionToken
  });
});

// Endpoint para reclamar un workspace preconstruido
app.post('/workspaces/:id/claim', (req, res) => {
  const workspaceId = req.params.id;
  const userId = req.body.userId;

  const ws = workspaces.get(workspaceId);
  if (!ws || !ws.isPrebuilt) {
    return res.status(404).json({ error: 'Workspace not found or not prebuilt' });
  }

  // Se genera un nuevo token de sesión para el usuario que reclama el workspace
  const newSessionToken = generateSessionToken(userId, workspaceId);

  // VULNERABILIDAD CLAVE:
  // - Se cambia el ownerUserId y se asigna un nuevo token al usuario que reclama
  // - PERO el token anterior del usuario de prebuilds NO se invalida ni se elimina
  //   de las plantillas persistidas.
  ws.ownerUserId = userId;
  ws.claimedBy = userId;
  ws.sessionToken = newSessionToken;
  workspaces.set(workspaceId, ws);

  // La plantilla antigua sigue conteniendo coder_workspace_owner.session_token
  // del usuario de prebuilds, que continúa siendo válido.

  res.json({
    message: 'Workspace claimed',
    workspaceId,
    sessionToken: newSessionToken
  });
});

// Endpoint que simula acceso a un workspace usando un token de sesión
app.get('/workspaces/:id', (req, res) => {
  const workspaceId = req.params.id;
  const token = req.headers['x-session-token'];

  const ws = workspaces.get(workspaceId);
  if (!ws) {
    return res.status(404).json({ error: 'Workspace not found' });
  }

  // VULNERABILIDAD: no se comprueba si el token pertenece al usuario actual,
  // solo se compara con el token almacenado. El token antiguo del usuario
  // de prebuilds sigue siendo válido si alguien lo obtiene desde la plantilla.
  if (token !== ws.sessionToken) {
    return res.status(401).json({ error: 'Invalid session token' });
  }

  res.json({
    id: ws.id,
    ownerUserId: ws.ownerUserId,
    claimedBy: ws.claimedBy,
    isPrebuilt: ws.isPrebuilt
  });
});

app.listen(3000, () => {
  console.log('Insecure server listening on port 3000');
});
