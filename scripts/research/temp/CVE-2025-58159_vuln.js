const express = require('express');
const multer = require('multer');
const fs = require('fs');
const path = require('path');

const app = express();

// Carpeta donde se "guardan" las planillas/subidas
const UPLOAD_DIR = path.join(__dirname, 'uploads');
if (!fs.existsSync(UPLOAD_DIR)) {
  fs.mkdirSync(UPLOAD_DIR, { recursive: true });
}

// Configuración vulnerable de multer: usa el nombre original del archivo
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, UPLOAD_DIR);
  },
  filename: (req, file, cb) => {
    // VULNERABLE: se usa el nombre original sin validación
    // Un atacante puede subir "reporte.xlsx.php" con código PHP incrustado
    cb(null, file.originalname);
  }
});

const upload = multer({ storage });

// Endpoint vulnerable: permite subir "planillas" pero no valida extensión ni contenido
app.post('/upload-spreadsheet', upload.single('spreadsheet'), (req, res) => {
  if (!req.file) {
    return res.status(400).send('No file uploaded');
  }

  // VULNERABLE: se asume que es una planilla, pero podría ser .php o .xlsx.php
  // El archivo queda accesible en disco con el nombre controlado por el usuario
  const savedPath = path.join(UPLOAD_DIR, req.file.filename);

  // Ejemplo de respuesta que podría revelar la ruta al atacante
  res.json({
    message: 'File uploaded (vulnerable)',
    filename: req.file.filename,
    path: savedPath
  });
});

// Servir estáticamente la carpeta de uploads (aún más peligroso si el servidor interpreta PHP)
// En un entorno con PHP-FPM/Apache/Nginx mal configurado, un .php aquí podría ejecutarse.
app.use('/files', express.static(UPLOAD_DIR));

app.listen(3000, () => {
  console.log('Vulnerable server listening on port 3000');
});
