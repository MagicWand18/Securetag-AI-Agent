const express = require('express');
const axios = require('axios');
const xml2js = require('xml2js');
const { URL } = require('url');

// Versión segura del mismo patrón: se valida la URL, se limita el tamaño
// de la respuesta y se configura el parser XML para mitigar XML Injection/XXE.

const app = express();
app.use(express.json());

function fakeAuth(req, res, next) {
  const token = req.headers['x-auth-token'];
  if (!token || token !== 'valid-token') {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  next();
}

// Lista blanca de dominios permitidos para sitemaps
const ALLOWED_SITEMAP_HOSTS = new Set(['example.com', 'static.example.com']);

function validateSitemapUrl(sitemapUrl) {
  let parsed;
  try {
    parsed = new URL(sitemapUrl);
  } catch {
    throw new Error('Invalid sitemap URL');
  }

  if (!['http:', 'https:'].includes(parsed.protocol)) {
    throw new Error('Only HTTP/HTTPS protocols are allowed');
  }

  if (!ALLOWED_SITEMAP_HOSTS.has(parsed.hostname)) {
    throw new Error('Sitemap host is not allowed');
  }

  return parsed.toString();
}

app.post('/monitors', fakeAuth, async (req, res) => {
  try {
    const { sitemapUrl } = req.body;
    if (!sitemapUrl) {
      return res.status(400).json({ error: 'sitemapUrl is required' });
    }

    const safeUrl = validateSitemapUrl(sitemapUrl);

    // Limitar tamaño de respuesta para evitar ataques de expansión
    const response = await axios.get(safeUrl, {
      timeout: 5000,
      maxContentLength: 1024 * 1024, // 1 MB
      responseType: 'text'
    });

    const xmlContent = response.data;

    // Configuración segura del parser:
    // - explicitCharkey / explicitRoot / explicitArray para tener control
    // - normalizeTags para evitar trucos de casing
    // - NO se resuelven entidades externas ni DTD (xml2js no las procesa
    //   por defecto, pero se asume configuración estricta y validación extra).
    const parser = new xml2js.Parser({
      explicitCharkey: false,
      explicitRoot: true,
      explicitArray: true,
      normalizeTags: true,
      // En entornos donde el parser subyacente soporte DTD/entidades externas,
      // se debe desactivar explícitamente. xml2js en sí no las procesa, pero
      // esta opción ilustra la intención de endurecer la configuración.
      // strict: true fuerza un parsing más estricto.
      strict: true
    });

    parser.parseString(xmlContent, (err, result) => {
      if (err) {
        return res.status(400).json({ error: 'Invalid XML sitemap' });
      }

      const urls = [];
      const urlset = result.urlset;
      if (urlset && Array.isArray(urlset.url)) {
        urlset.url.forEach((u) => {
          if (u.loc && u.loc[0] && typeof u.loc[0] === 'string') {
            // Validar que la URL extraída sea razonable (opcional)
            try {
              const locUrl = new URL(u.loc[0]);
              if (['http:', 'https:'].includes(locUrl.protocol)) {
                urls.push(locUrl.toString());
              }
            } catch {
              // Ignorar URLs inválidas
            }
          }
        });
      }

      return res.json({
        message: 'Monitor created (SAFE XML parsing)',
        sitemapUrl: safeUrl,
        urls
      });
    });
  } catch (e) {
    return res.status(400).json({ error: e.message });
  }
});

app.listen(3001, () => {
  console.log('Safe server listening on port 3001');
});
