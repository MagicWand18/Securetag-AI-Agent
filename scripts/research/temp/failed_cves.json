[
  {
    "id": "CVE-2024-27443",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202427443\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >-\n      Posible XSS reflejado al construir HTML con datos controlados por el usuario (p.ej. req.query/req.body/req.params)\n      mediante template literals o concatenación y enviarlo como 'text/html' (res.send/res.end). Esto es explotable en\n      escenarios tipo CVE-2024-27443 (inyección de contenido en UI webmail/calendario), permitiendo ejecutar JavaScript\n      en el navegador de la víctima. Sanitiza/escapa la salida o usa un motor de plantillas con auto-escape.\n    metadata:\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      owasp: \"A03:2021 - Injection\"\n      category: security\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2024-27443\"\n    patterns:\n      - pattern-inside: |\n          $APP.get($ROUTE, ($REQ, $RES) => {\n            ...\n          })\n      - pattern-either:\n          # Caso 1: template literal con interpolación de dato no confiable\n          - patterns:\n              - pattern: |\n                  $RES.send(`...${$X}...`)\n              - metavariable-pattern:\n                  metavariable: $X\n                  pattern-either:\n                    - pattern: $REQ.query.$P\n                    - pattern: $REQ.body.$P\n                    - pattern: $REQ.params.$P\n                    - pattern: $REQ.headers[$H]\n                    - pattern: $REQ.get($H)\n          # Caso 2: concatenación de strings con dato no confiable\n          - patterns:\n              - pattern: |\n                  $RES.send($A + $X + $B)\n              - metavariable-pattern:\n                  metavariable: $X\n                  pattern-either:\n                    - pattern: $REQ.query.$P\n                    - pattern: $REQ.body.$P\n                    - pattern: $REQ.params.$P\n                    - pattern: $REQ.headers[$H]\n                    - pattern: $REQ.get($H)\n          # Caso 3: construir HTML en variable y luego enviarlo\n          - patterns:\n              - pattern: |\n                  $HTML = `...${$X}...`\n              - pattern: |\n                  $RES.send($HTML)\n              - metavariable-pattern:\n                  metavariable: $X\n                  pattern-either:\n                    - pattern: $REQ.query.$P\n                    - pattern: $REQ.body.$P\n                    - pattern: $REQ.params.$P\n                    - pattern: $REQ.headers[$H]\n                    - pattern: $REQ.get($H)\n      # Aumenta precisión: solo cuando se sirve como HTML (como en el ejemplo)\n      - pattern-either:\n          - pattern: |\n              $RES.set('Content-Type', 'text/html; charset=utf-8')\n          - pattern: |\n              $RES.set(\"Content-Type\", \"text/html; charset=utf-8\")\n          - pattern: |\n              $RES.set('Content-Type', 'text/html')\n          - pattern: |\n              $RES.set(\"Content-Type\", \"text/html\")\n          - pattern: |\n              $RES.type('html')\n          - pattern: |\n              $RES.type(\"html\")"
  },
  {
    "id": "CVE-2024-37383",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202437383\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible vulnerabilidad similar a CVE-2024-37383: contenido SVG controlado por el\n      usuario se inserta directamente en una respuesta HTML sin sanitización. Esto puede\n      permitir la inyección de elementos/atributos SVG peligrosos (por ejemplo, <animate>,\n      onbegin, etc.) y conducir a XSS o ejecución de código en el navegador. Valida y\n      sanitiza estrictamente cualquier SVG antes de incrustarlo en HTML.\n    patterns:\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          })\n      - pattern: |\n          const $HTML = `\n            ...\n            ${$SVG}\n            ...\n          `;\n      - pattern: |\n          $RES.send($HTML)\n      - pattern-either:\n          - pattern: |\n              $SVG = $REQ.query.$PARAM\n          - pattern: |\n              $SVG = $REQ.body.$PARAM\n          - pattern: |\n              $SVG = $REQ.params.$PARAM\n          - pattern: |\n              $SVG = $REQ.$ANY[$PARAM]\n    metadata:\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2024-37383\""
  },
  {
    "id": "CVE-2024-6670",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve20246670\n    languages:\n      - javascript\n      - typescript\n    message: >\n      Posible inyección SQL similar a CVE-2024-6670: se construye una consulta SQL\n      concatenando directamente parámetros controlados por el usuario (por ejemplo,\n      username/password de un endpoint de login) en un SELECT sobre la tabla de\n      usuarios. Un atacante no autenticado puede manipular el valor de estos\n      parámetros (por ejemplo, con ' OR '1'='1 o UNION SELECT ...) para extraer\n      credenciales cifradas u otros datos sensibles del único usuario configurado.\n      Usa siempre consultas parametrizadas/preparadas en lugar de concatenar\n      cadenas SQL.\n    severity: ERROR\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2024-6670\"\n    patterns:\n      # 1) Estamos dentro de un handler HTTP típico (Express) que recibe req/res\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          })\n      # 2) Se construye una cadena SQL con template literal o concatenación\n      #    que contiene un SELECT sobre una tabla de usuarios\n      - pattern-either:\n          - pattern: |\n              const $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $COND`;\n          - pattern: |\n              let $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $COND`;\n          - pattern: |\n              var $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $COND`;\n          - pattern: |\n              const $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $COND;\n          - pattern: |\n              let $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $COND;\n          - pattern: |\n              var $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $COND;\n      # 3) La condición de la cláusula WHERE incluye interpolación directa de\n      #    datos provenientes del cuerpo de la petición (req.body.*),\n      #    típico de un login vulnerable.\n      - pattern-either:\n          - pattern: |\n              const $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}' AND $FIELD2 = '${$REQ.body.$PARAM2}'`;\n          - pattern: |\n              let $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}' AND $FIELD2 = '${$REQ.body.$PARAM2}'`;\n          - pattern: |\n              var $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}' AND $FIELD2 = '${$REQ.body.$PARAM2}'`;\n          - pattern: |\n              const $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}'`;\n          - pattern: |\n              let $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}'`;\n          - pattern: |\n              var $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}'`;\n          - pattern: |\n              const $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $FIELD + \" = '\" + $REQ.body.$PARAM + \"'\";\n          - pattern: |\n              let $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $FIELD + \" = '\" + $REQ.body.$PARAM + \"'\";\n          - pattern: |\n              var $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $FIELD + \" = '\" + $REQ.body.$PARAM + \"'\";\n      # 4) La consulta se ejecuta mediante un cliente SQL típico de Node.js\n      - pattern-either:\n          - pattern: |\n              $DB.query($SQL, ...);\n          - pattern: |\n              $DB.execute($SQL, ...);\n          - pattern: |\n              $DB.query($SQL, ($ERR, $RESULTS) => {\n                ...\n              });\n          - pattern: |\n              $DB.execute($SQL, ($ERR, $RESULTS) => {\n                ...\n              })"
  },
  {
    "id": "CVE-2023-5631",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3
  },
  {
    "id": "CVE-2023-34362",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202334362\n    languages:\n      - javascript\n      - typescript\n    message: >\n      Posible inyección SQL no autenticada similar a CVE-2023-34362: se concatena\n      directamente un parámetro controlado por el usuario en una consulta SQL\n      (`db.query(sql, ...)`) sin usar parámetros preparados ni escape seguro.\n      Un atacante puede manipular el parámetro (por ejemplo `?id=1;DROP TABLE users--`)\n      para ejecutar SQL arbitrario, lo que permite acceso o destrucción de datos.\n    severity: ERROR\n    metadata:\n      cve: \"CVE-2023-34362\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology:\n        - nodejs\n        - express\n        - mysql\n      likelihood: \"high\"\n      impact: \"high\"\n      vulnerability_class:\n        - \"SQL Injection\"\n    patterns:\n      - pattern-either:\n          # Caso: template string con interpolación de variable\n          - pattern: |\n              $DB.$QUERY_FN(`... = ${$PARAM}...`, ...)\n          # Caso: concatenación con +\n          - pattern: |\n              $DB.$QUERY_FN(\"...\" + $PARAM + \"...\", ...)\n      - pattern-inside: |\n          $DB = require('mysql2');\n          ...\n          $CONN = $DB.$CREATE_CONN(...);\n          ...\n          app.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n            $PARAM = $REQ.$SRC.$FIELD;\n            ...\n            $CONN.$QUERY_FN($SQL, ...);\n            ...\n          });\n      - metavariable-pattern:\n          metavariable: $SRC\n          pattern-either:\n            - pattern: query\n            - pattern: params\n            - pattern: body\n      - metavariable-pattern:\n          metavariable: $QUERY_FN\n          pattern-either:\n            - pattern: query\n            - pattern: execute\n      - metavariable-pattern:\n          metavariable: $CREATE_CONN\n          pattern-either:\n            - pattern: createConnection\n            - pattern: createPool\n      - pattern-not: |\n          $DB.$QUERY_FN($SQL, [$PARAM], ...)"
  },
  {
    "id": "CVE-2020-1956",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3
  },
  {
    "id": "CVE-2009-1151",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve20091151\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible vulnerabilidad similar a CVE-2009-1151: se está generando un archivo\n      PHP de configuración que incluye directamente datos controlados por el usuario\n      (por ejemplo, desde req.body) dentro de código PHP. Si un atacante puede\n      inyectar comillas o código PHP en estos valores, el archivo resultante será\n      interpretado por el intérprete PHP, permitiendo ejecución remota de código.\n      Valida y escapa estrictamente cualquier dato antes de escribirlo en archivos\n      PHP que luego serán incluidos o ejecutados por el servidor.\n    patterns:\n      - pattern-inside: |\n          fs.writeFile($CONFIG_PATH, $CONTENT, ...)\n      - pattern: |\n          `<?php\n          $... = $...(\n            $... => '${...}',\n            ...\n          );\n          ?>`\n      - pattern-inside: |\n          const $CONTENT = `<?php\n          $... = $...(\n            $... => '${...}',\n            ...\n          );\n          ?>`;\n      - pattern-either:\n          - pattern: |\n              const $REQ = require('express');\n              ...\n              $APP.$METHOD(..., (req, res, ...) => {\n                ...\n                $VAR = req.body.$FIELD || $DEFAULT;\n                ...\n              });\n          - pattern: |\n              $APP.$METHOD(..., (req, res, ...) => {\n                ...\n                $VAR = req.body.$FIELD || $DEFAULT;\n                ...\n              });\n    metadata:\n      cwe: \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2009-1151\""
  },
  {
    "id": "CVE-2021-21315",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3
  },
  {
    "id": "CVE-2025-58745",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558745\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible explotación de CVE-2025-58745: carga de archivos Excel validando\n      únicamente el MIME type declarado por el cliente (`file.mimetype`) en\n      `multer.fileFilter`, sin validar extensión ni contenido real. Un atacante\n      puede subir un archivo malicioso (por ejemplo, un webshell `.php`) con\n      magic bytes y/o cabeceras manipuladas para que parezca un Excel y quede\n      accesible o ejecutable en el servidor.\n    metadata:\n      cve: \"CVE-2025-58745\"\n      source: \"CISA_KEV\"\n      category: \"file-upload\"\n      likelihood: \"high\"\n      impact: \"high\"\n      confidence: \"medium\"\n    patterns:\n      - pattern-inside: |\n          const $MULTER = require('multer');\n          ...\n      - pattern-inside: |\n          const $STORAGE = $MULTER.diskStorage({\n            ...\n          });\n      - pattern-inside: |\n          const $UPLOAD = $MULTER({\n            storage: $STORAGE,\n            fileFilter: ($REQ, $FILE, $CB) => {\n              ...\n            }\n          });\n      - pattern: |\n          fileFilter: ($REQ, $FILE, $CB) => {\n            const $ALLOWED = [...];\n            if ($ALLOWED.includes($FILE.mimetype)) {\n              return $CB(null, true);\n            }\n            return $CB(new Error(...));\n          }\n      - pattern-not: |\n          fileFilter: ($REQ, $FILE, $CB) => {\n            ...\n            if ($ALLOWED.includes($FILE.mimetype) && $FILE.originalname.endsWith('.xlsx')) {\n              return $CB(null, true);\n            }\n            ...\n          }"
  },
  {
    "id": "CVE-2025-58453",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558453\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-58453): se construye dinámicamente una consulta SQL\n      concatenando directamente datos controlados por el usuario (por ejemplo, req.query.id_anexo)\n      en la cláusula WHERE antes de pasarlos a db.query. Un atacante puede manipular el parámetro\n      para alterar la consulta, extraer o modificar datos sensibles, o dañar la base de datos.\n      Usa consultas parametrizadas/preparadas (placeholders) en lugar de concatenación de strings.\n    metadata:\n      cve: \"CVE-2025-58453\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql2\"]\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      vulnerability_class: [\"SQL Injection\"]\n    patterns:\n      - pattern-either:\n          # Caso típico: template string con interpolación de variable controlada\n          - pattern: |\n              $DB.$QUERY_FN(`... = ${$USER_INPUT}...`, ...)\n          # Concatenación con +\n          - pattern: |\n              $DB.$QUERY_FN(\"...\" + $USER_INPUT + \"...\", ...)\n          - pattern: |\n              $DB.$QUERY_FN('...' + $USER_INPUT + '...', ...)\n      - pattern-inside: |\n          const $APP = require('express');\n          ...\n          $APP.$METHOD($ROUTE, ($REQ, $RES, ...$REST) => {\n            ...\n            $USER_INPUT = $REQ.$PROP.$KEY;\n            ...\n          });\n      - pattern-inside: |\n          const $DB = require('mysql2').createConnection(...);\n          ...\n      - pattern-inside: |\n          $DB.$QUERY_FN($SQL, ...);\n      - pattern-not: |\n          $DB.$QUERY_FN($SQL, [$USER_INPUT, ...], ...);\n      - pattern-not: |\n          $DB.$QUERY_FN($SQL, { ... }, ...);"
  },
  {
    "id": "CVE-2025-48208",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202548208\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible LDAP Injection (CVE-2025-48208): se construye un filtro LDAP concatenando\n      directamente datos controlados por el usuario (por ejemplo, `req.body.filter`) en\n      la cadena de búsqueda (`opts.filter` o parámetro `filter` de `client.search`).\n      Un atacante autenticado puede inyectar operadores LDAP especiales (`*`, `)`, `(|`, etc.)\n      para alterar la consulta, eludir controles de acceso o extraer información sensible.\n      Valida y escapa los valores de entrada antes de construir filtros LDAP o utiliza\n      APIs que manejen parámetros de forma segura.\n    metadata:\n      cve: CVE-2025-48208\n      source: CISA_KEV\n      category: security\n      technology: [nodejs, express, ldapjs]\n      cwe: \"CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\"\n    patterns:\n      - pattern-either:\n          # Caso 1: filtro se pasa directamente como string concatenado al parámetro filter de client.search\n          - pattern: |\n              $CLIENT.search($BASE_DN, { ..., filter: $FILTER, ... }, ...);\n          # Caso 2: filtro se pasa como segundo argumento (forma abreviada) a client.search\n          - pattern: |\n              $CLIENT.search($BASE_DN, $FILTER, ...);\n      - pattern-inside: |\n          $CLIENT = require('ldapjs');\n          ...\n      - pattern-inside: |\n          const $APP = require('express')();\n          ...\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ..., (req, res, ... ) => {\n            ...\n          });\n      - pattern-either:\n          # Filtro construido con template string que incluye datos de req.*\n          - pattern: |\n              $FILTER = `...${req.$SRC}...`;\n          - pattern: |\n              $FILTER = `...${req.$SRC.$FIELD}...`;\n          # Filtro construido con concatenación de strings que incluye datos de req.*\n          - pattern: |\n              $FILTER = \"...\"+req.$SRC+\"...\";\n          - pattern: |\n              $FILTER = \"...\"+req.$SRC.$FIELD+\"...\";\n          - pattern: |\n              $FILTER = req.$SRC + \"...\";\n          - pattern: |\n              $FILTER = req.$SRC.$FIELD + \"...\";\n      - metavariable-pattern:\n          metavariable: $SRC\n          pattern: |\n            body\n      - pattern-not: |\n          $FILTER = $SANITIZE(...);\n      - pattern-not: |\n          $FILTER = $SANITIZE(req.$SRC);\n      - pattern-not: |\n          $FILTER = $SANITIZE(req.$SRC.$FIELD);"
  },
  {
    "id": "CVE-2025-58454",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558454\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-58454): se construye dinámicamente una\n      consulta SQL con datos controlados por el usuario (por ejemplo, req.query.id_memorando)\n      mediante concatenación/interpolación de strings antes de pasarlos a mysql2.connection.query().\n      Un atacante puede manipular el parámetro para alterar la consulta SQL, extraer o modificar datos.\n      Usa consultas parametrizadas/preparadas en lugar de interpolar directamente los valores.\n    metadata:\n      cve: \"CVE-2025-58454\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql2\"]\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n    patterns:\n      - pattern-inside: |\n          const express = require('express');\n          ...\n      - pattern-inside: |\n          $APP = express();\n          ...\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          });\n      - pattern-inside: |\n          $ID = $REQ.query.id_memorando;\n          ...\n      - pattern: |\n          $SQL = `SELECT * FROM $TABLE WHERE id_memorando = ${$ID}`;\n      - pattern-either:\n          - pattern: |\n              $CONN.query($SQL, ...);\n          - pattern: |\n              $CONN.query($SQL, ($ERR, $RESULTS) => {\n                ...\n              });\n    fix: >\n      Usa consultas parametrizadas, por ejemplo:\n      const sql = 'SELECT * FROM despachos WHERE id_memorando = ?';\n      connection.query(sql, [idMemorando], ...);"
  },
  {
    "id": "CVE-2025-58445",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558445\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Exposición de metadatos internos de compilación y versión a través de un endpoint público.\n      Esta práctica facilita el fingerprinting de la aplicación (nombre del servicio, versión exacta,\n      hash de commit, fecha de build, versión de runtime, SO/arquitectura y dependencias), lo que\n      puede ser aprovechado por un atacante para seleccionar exploits específicos o preparar ataques\n      dirigidos (CVE-2025-58445). Limita la información expuesta en endpoints de salud/estado a lo\n      estrictamente necesario para monitoreo.\n    patterns:\n      - pattern-either:\n          # Caso 1: objeto buildInfo (o similar) con metadatos internos\n          - pattern: |\n              const $BUILDINFO = {\n                ...\n              };\n          # Caso 2: endpoint Express que expone buildInfo/metadata detallada vía res.json\n          - pattern: |\n              $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n                ...\n                $RES.json({\n                  ...,\n                  $KEY: $BUILDINFO,\n                  ...\n                });\n              });\n      - pattern-inside: |\n          const $APP = require('express')();\n          ...\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          });\n      - metavariable-pattern:\n          metavariable: $ROUTE\n          pattern: |\n            '/status'\n    metadata:\n      cve: CVE-2025-58445\n      source: CISA_KEV\n      category: security\n      technology:\n        - express\n      references:\n        - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-58445\n      description: >\n        Detección de endpoints de estado/health en aplicaciones Express que exponen metadatos\n        internos de build y versión (buildInfo) de forma pública, facilitando el fingerprinting\n        y la selección de exploits dirigidos."
  },
  {
    "id": "CVE-2025-9941",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve20259941\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible carga de archivos insegura asociada a CVE-2025-9941: se usa\n      `multer.diskStorage` para guardar archivos subidos en un directorio\n      accesible públicamente usando `file.originalname` como nombre final,\n      sin validación de tipo, tamaño o extensión. Un atacante puede subir\n      archivos maliciosos (por ejemplo, scripts ejecutables) y acceder a\n      ellos directamente vía HTTP, lo que puede derivar en ejecución de\n      código, defacement o exfiltración de datos. Valida estrictamente el\n      tipo de archivo, tamaño, extensión y evita usar el nombre original\n      del archivo en rutas públicas.\n    metadata:\n      cve: \"CVE-2025-9941\"\n      source: \"CISA_KEV\"\n      category: security\n      technology:\n        - express\n        - nodejs\n        - multer\n    patterns:\n      - pattern-either:\n          # Patrón 1: configuración de diskStorage con destino en carpeta pública y uso de originalname\n          - pattern: |\n              const $M = require('multer');\n              ...\n              const $STORAGE = $M.diskStorage({\n                destination: function ($REQ, $FILE, $CB) {\n                  $CB(null, $DEST);\n                },\n                filename: function ($REQ2, $FILE2, $CB2) {\n                  $CB2(null, $FILE2.originalname);\n                }\n              });\n          # Patrón 2: uso de multer.diskStorage con filename basado en originalname (forma más genérica)\n          - pattern: |\n              $MULTER.diskStorage({\n                ...\n                filename: function ($REQ, $FILE, $CB) {\n                  $CB(..., $FILE.originalname);\n                }\n              })\n      # Debe existir un uso de `upload.single(...)` o similar en una ruta Express (indica endpoint de subida)\n      - pattern-either:\n          - pattern: |\n              $APP.post($ROUTE, $UPLOAD.single($FIELD), ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $APP.post($ROUTE, $UPLOAD.single($FIELD), function ($REQ, $RES) {\n                ...\n              })\n          - pattern: |\n              $APP.$METHOD($ROUTE, $UPLOAD.single($FIELD), ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $APP.$METHOD($ROUTE, $UPLOAD.single($FIELD), function ($REQ, $RES) {\n                ...\n              })\n    fix: >\n      No uses `file.originalname` directamente como nombre final ni guardes\n      archivos subidos en rutas públicas sin validación. Genera nombres\n      aleatorios seguros, aplica filtros de tipo MIME/extensión, límites de\n      tamaño y, si es posible, almacena los archivos fuera del árbol\n      público de la aplicación."
  },
  {
    "id": "CVE-2025-10012",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202510012\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-10012-like): se construye dinámicamente\n      una consulta SQL concatenando directamente datos controlados por el\n      usuario (por ejemplo, req.query.ref_cod_aluno) en la cadena de consulta\n      antes de pasarlos a db.query(). Un atacante puede manipular el parámetro\n      para alterar la consulta SQL, extraer o modificar datos sensibles o\n      comprometer la base de datos. Use consultas parametrizadas/preparadas\n      (placeholders) en lugar de concatenación de strings.\n    metadata:\n      cve: \"CVE-2025-10012\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql2\"]\n      vulnerability: \"sql-injection\"\n    patterns:\n      - pattern-either:\n          # Caso 1: template string con interpolación de variable controlada\n          - pattern: |\n              $DB.$QUERY_FN(`... = ${$USER_INPUT} ...`, ...)\n          # Caso 2: concatenación clásica con +\n          - pattern: |\n              $DB.$QUERY_FN(\"...\" + $USER_INPUT + \"...\", ...)\n      - pattern-inside: |\n          app.$ROUTE_METHOD($ROUTE, ($REQ, $RES, ...) => {\n            ...\n          })\n      - pattern-inside: |\n          const $USER_INPUT = $REQ.query.$PARAM;\n      - pattern-inside: |\n          const $DB = require('mysql2').createConnection(...);\n      - metavariable-regex:\n          metavariable: $QUERY_FN\n          regex: ^(query|execute|executeQuery|raw|run)$\n      - metavariable-regex:\n          metavariable: $ROUTE_METHOD\n          regex: ^(get|post|put|delete|patch|all|use)$"
  },
  {
    "id": "CVE-2025-10098",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202510098\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-10098): se construye dinámicamente una\n      consulta SQL concatenando o interpolando datos controlados por el usuario\n      (por ejemplo, parámetros de `req.body`, `req.query` o similares) en la\n      cadena de consulta pasada a `db.query`/`connection.query` de `mysql`. Un\n      atacante puede manipular estos valores para alterar la consulta SQL,\n      exfiltrar datos o escalar privilegios. Usa consultas parametrizadas\n      (placeholders `?` o bindings) en lugar de concatenar/interpolar valores\n      directamente en la cadena SQL.\n    metadata:\n      cve: \"CVE-2025-10098\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql\"]\n      vulnerability: \"sql-injection\"\n    patterns:\n      - pattern-either:\n          # mysql / mysql2 style: db.query(sql, ...)\n          - pattern: |\n              $DB.query($SQL, ...);\n          # connection.query(sql, ...)\n          - pattern: |\n              $CONN.query($SQL, ...);\n      - pattern-either:\n          # SQL construido con template literal que incluye valores no constantes\n          - pattern: |\n              const $SQL = `$X${...}$Y`;\n          - pattern: |\n              let $SQL = `$X${...}$Y`;\n          - pattern: |\n              var $SQL = `$X${...}$Y`;\n          # SQL construido por concatenación con +\n          - pattern: |\n              const $SQL = $X + $Y;\n          - pattern: |\n              let $SQL = $X + $Y;\n          - pattern: |\n              var $SQL = $X + $Y;\n      - pattern-either:\n          # Origen típico de datos controlados por el usuario en Express\n          - pattern: |\n              $SRC = $REQ.body.$FIELD;\n          - pattern: |\n              $SRC = $REQ.query.$FIELD;\n          - pattern: |\n              $SRC = $REQ.params.$FIELD;\n          - pattern: |\n              $SRC = $REQ.headers[$H];\n      - pattern-either:\n          # El valor controlado por el usuario se usa en la construcción del SQL\n          - pattern: |\n              const $SQL = ... $SRC ...;\n          - pattern: |\n              let $SQL = ... $SRC ...;\n          - pattern: |\n              var $SQL = ... $SRC ...;\n          - pattern: |\n              $SQL = ... $SRC ...;\n      - pattern-not: |\n          // Exclusión básica de consultas parametrizadas con placeholders\n          $DB.query($SQL, [...]);\n      - pattern-not: |\n          // Exclusión básica de consultas parametrizadas con objeto de parámetros\n          $DB.query($SQL, {...});\n    fix: >\n      Usa consultas parametrizadas. Por ejemplo:\n      `const sql = \"UPDATE users SET full_name = ?, email = ? WHERE id = ?\"; db.query(sql, [fullName, email, uid]);`"
  },
  {
    "id": "CVE-2025-57819",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202557819\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible bypass de autenticación de administrador y ejecución de SQL arbitrario\n      similar a CVE-2025-57819: se usa un valor controlado por el usuario (cabecera,\n      cookie o cuerpo de la petición) para construir una consulta SQL de autenticación\n      mediante concatenación de strings, y si existe cualquier fila se considera\n      al usuario como administrador. Luego, en un endpoint privilegiado (por ejemplo\n      /admin o similar), se ejecuta directamente una sentencia SQL arbitraria\n      proporcionada por el cliente (p.ej. req.body.rawSql) con pool.query/rawQuery.\n      Esto permite a un atacante eludir la autenticación y ejecutar comandos SQL\n      arbitrarios en la base de datos, pudiendo derivar en RCE en entornos similares\n      al descrito en CVE-2025-57819.\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2025-57819\"\n    patterns:\n      # 1) Función de autenticación insegura basada en token/cabecera/cookie\n      - pattern-inside: |\n          async function $FUNC($REQ, ...) {\n            ...\n          }\n      - pattern-either:\n          - pattern: |\n              const $RAW = $REQ.headers[$KEY] || ...;\n          - pattern: |\n              const $RAW = $REQ.cookies[$KEY] || ...;\n          - pattern: |\n              const $RAW = $REQ.body[$KEY] || ...;\n      - pattern: |\n          const $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $COL = '${$RAW}'`;\n      - pattern: |\n          const [$ROWS] = await $POOL.query($SQL);\n      - pattern: |\n          if ($ROWS.length === 0) {\n            return false;\n          }\n      - pattern: |\n          return true;\n\n      # 2) Endpoint \"admin\" que llama a la función anterior y ejecuta SQL arbitrario del body\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, async ($REQ2, $RES, ...) => {\n            ...\n          })\n      - pattern-either:\n          - pattern: |\n              $APP.post($ROUTE, async ($REQ2, $RES, ...) => {\n                ...\n              })\n          - pattern: |\n              $APP.get($ROUTE, async ($REQ2, $RES, ...) => {\n                ...\n              })\n      - pattern: |\n          const $ISADMIN = await $FUNC($REQ2);\n      - pattern: |\n          if (!$ISADMIN) {\n            return $RES.status(401).json(...);\n          }\n      - pattern: |\n          const { $RAWSQL } = $REQ2.body;\n      - pattern-either:\n          - pattern: |\n              await $POOL.query($RAWSQL);\n          - pattern: |\n              $POOL.query($RAWSQL);"
  },
  {
    "id": "CVE-2024-42009",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202442009\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible vulnerabilidad tipo CVE-2024-42009: contenido HTML controlado por un atacante\n      se devuelve o propaga como \"ya sanitizado\" y luego se inserta directamente en una\n      respuesta HTML (por ejemplo, con res.send) sin escape ni sanitización adicional.\n      Esto permite XSS almacenado o reflejado cuando el HTML se muestra en el navegador.\n      Asegúrate de escapar/sanitizar el contenido antes de interpolarlo en la respuesta\n      o usa APIs que hagan escape automático.\n    metadata:\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2024-42009\"\n    patterns:\n      # 1) Detectamos una función que actúa como \"desanitizadora\" o passthrough de HTML\n      - pattern: |\n          function $FNAME($ARG, ...) {\n            ...\n            return $ARG;\n          }\n      # 2) Dentro del handler de Express, se llama a esa función con datos potencialmente controlados\n      #    por el usuario (req.query, req.body, req.params, etc.)\n      - pattern-inside: |\n          app.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          })\n      - pattern: |\n          $BODY = $FNAME($USER_INPUT);\n      - pattern-either:\n          - pattern: $USER_INPUT = $REQ.query.$FIELD;\n          - pattern: $USER_INPUT = $REQ.query[$FIELD];\n          - pattern: $USER_INPUT = $REQ.body.$FIELD;\n          - pattern: $USER_INPUT = $REQ.body[$FIELD];\n          - pattern: $USER_INPUT = $REQ.params.$FIELD;\n          - pattern: $USER_INPUT = $REQ.params[$FIELD];\n          - pattern: $USER_INPUT = $REQ.$ANYPROP;\n      # 3) El resultado de esa \"desanitización\" se inserta directamente en una plantilla HTML\n      #    enviada con res.send, usando interpolación de template string (${...})\n      - pattern-inside: |\n          $RES.send(`$HTML`);\n      - pattern: |\n          $RES.send(`...${$BODY}...`)"
  },
  {
    "id": "CVE-2024-11182",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202411182\n    languages:\n      - javascript\n      - typescript\n    message: >\n      Posible XSS almacenado/reflejado similar a CVE-2024-11182: contenido HTML de correo\n      (`rawEmailHtml` u otra variable) se inserta directamente en la respuesta HTML de Express\n      mediante `res.send()` sin sanitización ni escape. Un atacante puede inyectar `<script>`\n      u otras cargas maliciosas que se ejecutarán en el navegador del usuario. Valida o\n      sanitiza el HTML antes de insertarlo en la respuesta.\n    severity: ERROR\n    metadata:\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2024-11182\"\n    patterns:\n      - pattern-inside: |\n          app.$ROUTE($PATH, ($REQ, $RES) => {\n            ...\n          })\n      - pattern: |\n          $RES.setHeader(\"Content-Type\", \"text/html\" , ...);\n      - pattern: |\n          $RES.send(`...${$UNTRUSTED}...`);\n      - pattern-not: |\n          $RES.send(`...${sanitize($UNTRUSTED)}...`);\n      - pattern-not: |\n          $RES.send(`...${escape($UNTRUSTED)}...`);\n      - pattern-not: |\n          $RES.send(`...${$SANITIZER($UNTRUSTED)}...`)"
  },
  {
    "id": "CVE-2021-20123",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202120123\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >-\n      Posible Path Traversal (CVE-2021-20123): se construye una ruta de archivo a\n      partir de entrada controlada por el usuario (p.ej., req.query/req.params/req.body)\n      y luego se lee el archivo (fs.readFile / readFileSync / createReadStream) sin\n      validar que la ruta resultante permanezca dentro de un directorio base. Esto\n      permite usar secuencias como \"../\" para acceder a archivos arbitrarios y es\n      altamente explotable (probabilidad 94%).\n    metadata:\n      cwe: \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n      owasp: \"A01:2021 - Broken Access Control\"\n      category: security\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2021-20123\"\n    pattern-either:\n      # Caso típico: path.join(baseDir, userInput) -> fs.readFile(...)\n      - patterns:\n          - pattern-inside: |\n              $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $TARGET = $PATH.join($BASE, $USER_INPUT)\n          - metavariable-regex:\n              metavariable: $USER_INPUT\n              regex: ^(\\$REQ\\.(query|params|body)(\\.[A-Za-z0-9_$]+)?|\\$REQ\\[['\"](query|params|body)['\"]\\](\\[[^\\]]+\\])?)$\n          - pattern-either:\n              - pattern: $FS.readFile($TARGET, ...)\n              - pattern: $FS.readFileSync($TARGET, ...)\n              - pattern: $FS.createReadStream($TARGET, ...)\n              - pattern: $FS.open($TARGET, ...)\n              - pattern: $FS.openSync($TARGET, ...)\n          - pattern-not: |\n              if (!$TARGET.startsWith($BASE)) { ... }\n\n      # Variante: path.resolve(baseDir, userInput) -> fs.readFile(...)\n      - patterns:\n          - pattern-inside: |\n              $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $TARGET = $PATH.resolve($BASE, $USER_INPUT)\n          - metavariable-regex:\n              metavariable: $USER_INPUT\n              regex: ^(\\$REQ\\.(query|params|body)(\\.[A-Za-z0-9_$]+)?|\\$REQ\\[['\"](query|params|body)['\"]\\](\\[[^\\]]+\\])?)$\n          - pattern-either:\n              - pattern: $FS.readFile($TARGET, ...)\n              - pattern: $FS.readFileSync($TARGET, ...)\n              - pattern: $FS.createReadStream($TARGET, ...)\n              - pattern: $FS.open($TARGET, ...)\n              - pattern: $FS.openSync($TARGET, ...)\n          - pattern-not: |\n              if (!$TARGET.startsWith($BASE)) { ... }\n\n      # Caso directo: fs.readFile(path.join(baseDir, userInput), ...)\n      - patterns:\n          - pattern-inside: |\n              $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n                ...\n              })\n          - pattern-either:\n              - pattern: $FS.readFile($PATH.join($BASE, $USER_INPUT), ...)\n              - pattern: $FS.readFileSync($PATH.join($BASE, $USER_INPUT), ...)\n              - pattern: $FS.createReadStream($PATH.join($BASE, $USER_INPUT), ...)\n              - pattern: $FS.open($PATH.join($BASE, $USER_INPUT), ...)\n              - pattern: $FS.openSync($PATH.join($BASE, $USER_INPUT), ...)\n              - pattern: $FS.readFile($PATH.resolve($BASE, $USER_INPUT), ...)\n              - pattern: $FS.readFileSync($PATH.resolve($BASE, $USER_INPUT), ...)\n              - pattern: $FS.createReadStream($PATH.resolve($BASE, $USER_INPUT), ...)\n              - pattern: $FS.open($PATH.resolve($BASE, $USER_INPUT), ...)\n              - pattern: $FS.openSync($PATH.resolve($BASE, $USER_INPUT), ...)\n          - metavariable-regex:\n              metavariable: $USER_INPUT\n              regex: ^(\\$REQ\\.(query|params|body)(\\.[A-Za-z0-9_$]+)?|\\$REQ\\[['\"](query|params|body)['\"]\\](\\[[^\\]]+\\])?)$"
  },
  {
    "id": "CVE-2023-36847",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202336847\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible carga de archivos arbitrarios sin autenticación ni validación,\n      similar a CVE-2023-36847 (Juniper J-Web installAppPackage.php). Un\n      endpoint que acepta archivos mediante multer.diskStorage sin validar\n      tipo, tamaño ni nombre (usando file.originalname directamente) puede\n      permitir a un atacante subir paquetes maliciosos o ejecutar código\n      arbitrario en el servidor.\n    metadata:\n      cwe: \"CWE-434: Unrestricted Upload of File with Dangerous Type\"\n      owasp: \"A05:2021 - Security Misconfiguration\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2023-36847\"\n    patterns:\n      # 1) Uso de multer.diskStorage\n      - pattern-inside: |\n          const $MULTER = require('multer');\n          ...\n      - pattern: |\n          $STORAGE = $MULTER.diskStorage({\n            destination: ($REQ, $FILE, $CB) => {\n              $CB(null, $DEST);\n            },\n            filename: ($REQ2, $FILE2, $CB2) => {\n              $CB2(null, $FILE2.originalname);\n            },\n          });\n      # 2) Uso de ese storage en configuración de multer\n      - pattern: |\n          $UPLOAD = $MULTER({ storage: $STORAGE, ... });\n      # 3) Endpoint HTTP que usa upload.single(...) sin validaciones adicionales\n      - pattern-either:\n          - pattern: |\n              $APP.post($ROUTE, $UPLOAD.single($FIELD), ($REQ3, $RES3) => {\n                ...\n              });\n          - pattern: |\n              $ROUTER.post($ROUTE, $UPLOAD.single($FIELD), ($REQ3, $RES3) => {\n                ...\n              });"
  },
  {
    "id": "CVE-2016-3976",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve20163976\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible vulnerabilidad de directory traversal similar a CVE-2016-3976:\n      se concatena directamente un parámetro controlado por el usuario a una\n      ruta base (por ejemplo, BASE_DIR) y se usa en operaciones de lectura de\n      archivos (fs.readFile / fs.readFileSync / fs.createReadStream) sin\n      validar que la ruta resultante permanezca dentro del directorio esperado.\n      Un atacante puede usar secuencias como \"../\" o \"..\\\" para escapar del\n      directorio y leer archivos arbitrarios. Valida y normaliza la ruta antes\n      de usarla o restringe explícitamente el acceso a un directorio seguro.\n    patterns:\n      - pattern-inside: |\n          const $FS = require('fs');\n          ...\n      - pattern-inside: |\n          $FS.$READFUNC($FILEPATH, ...);\n      - pattern-either:\n          - pattern: |\n              $FILEPATH = require('path').join($BASEDIR, $USERINPUT);\n          - pattern: |\n              $FILEPATH = $PATHMOD.join($BASEDIR, $USERINPUT);\n      - pattern-not: |\n          $FILEPATH = $PATHMOD.join($BASEDIR, $USERINPUT);\n          if (!$FILEPATH.startsWith($BASEDIR)) {\n            ...\n          }\n      - pattern-not: |\n          $FILEPATH = $PATHMOD.join($BASEDIR, $USERINPUT);\n          if (!$FILEPATH.includes('..')) {\n            ...\n          }\n    metadata:\n      cwe: \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n      owasp: \"A01:2021 - Broken Access Control\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2016-3976\""
  },
  {
    "id": "CVE-2025-27915",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202527915\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible XSS al incrustar directamente contenido de archivos ICS en HTML\n      sin sanitización, similar a CVE-2025-27915. Un atacante puede controlar\n      campos como DESCRIPTION en el ICS e inyectar HTML/JS que se renderiza\n      en el navegador, permitiendo ejecución de código arbitrario.\n    metadata:\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2025-27915\"\n    patterns:\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          })\n      - pattern: |\n          const $ICS_CONTENT = $FS.readFileSync($PATH, 'utf8');\n      - pattern: |\n          const $DESC = $ICS_CONTENT.match(/DESCRIPTION:(.*)/);\n      - pattern: |\n          const $DESC_HTML = $DESC ? $DESC[1] : $FALLBACK;\n      - pattern: |\n          const $HTML = `\n            ...\n            ${$DESC_HTML}\n            ...\n          `;\n      - pattern: |\n          $RES.send($HTML);"
  },
  {
    "id": "CVE-2025-44823",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202544823\n    languages:\n      - javascript\n      - typescript\n    message: >\n      Posible exposición de API keys en texto claro a través de un endpoint que devuelve\n      la lista completa de usuarios sin filtrado de campos sensibles ni control de acceso\n      robusto. Este patrón es conceptualmente similar a CVE-2025-44823 en Nagios Log Server,\n      donde un endpoint `/api/system/get_users` permitía a cualquier usuario con un token\n      válido obtener usuarios y sus API keys en texto claro, posibilitando enumeración de\n      cuentas, escalada de privilegios y compromiso total del sistema.\n    severity: ERROR\n    metadata:\n      cwe: \"CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\"\n      owasp: \"A01:2021 - Broken Access Control\"\n      category: security\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: HIGH\n      impact: HIGH\n      confidence: MEDIUM\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2025-44823\"\n    patterns:\n      # 1) Un handler de ruta que devuelve directamente una colección de usuarios\n      - pattern: |\n          $APP.$METHOD($ROUTE, $MIDDLEWARE, ($REQ, $RES, ...$REST) => {\n            ...\n            $RES.json($USERS);\n            ...\n          });\n      # 2) La colección de usuarios contiene un campo de API key en texto claro\n      - pattern-inside: |\n          const $USERS = [\n            ...\n            {\n              ...,\n              $APIKEY_FIELD: $APIKEY_VALUE,\n              ...\n            },\n            ...\n          ];\n      # 3) El nombre del campo sugiere que es una API key o token sensible\n      - metavariable-regex:\n          metavariable: $APIKEY_FIELD\n          regex: '(?i)(api[_-]?key|apikey|token|access[_-]?token|secret)'"
  },
  {
    "id": "CVE-2025-63525",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202563525\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible control de acceso roto (CVE-2025-63525): este handler de ruta\n      permite operaciones sensibles (por ejemplo, borrado de recursos) para\n      cualquier usuario autenticado sin verificar el rol (hospital vs user) ni\n      la pertenencia del recurso al propietario. En el exploit real de\n      Blood Bank Management System 1.0, un usuario con rol \"user\" puede\n      reutilizar la sesión para invocar delete.php y borrar muestras de sangre\n      de hospitales, escalando privilegios. Asegúrate de validar explícitamente\n      el rol y la propiedad del recurso antes de ejecutar la operación.\n    patterns:\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          });\n      - pattern-either:\n          # 1) Operaciones de borrado/actualización sin comprobación de rol\n          - patterns:\n              - pattern: |\n                  if (!$REQ.session.user) {\n                    return $RES.$STATUS(...);\n                  }\n              - pattern-not: |\n                  if (!$REQ.session.user || $REQ.session.user.role !== $ROLE) {\n                    return $RES.$STATUS(...);\n                  }\n              - pattern-either:\n                  - pattern: |\n                      const $ID = parseInt($REQ.query.$PARAM, ...);\n                  - pattern: |\n                      const $ID = $REQ.query.$PARAM;\n                  - pattern: |\n                      const $ID = parseInt($REQ.body.$PARAM, ...);\n                  - pattern: |\n                      const $ID = $REQ.body.$PARAM;\n              - pattern-either:\n                  - pattern: |\n                      $COLLECTION.findIndex($F => $F.id === $ID)\n                  - pattern: |\n                      $COLLECTION.findIndex(($F) => $F.id === $ID)\n              - pattern: |\n                  const $INDEX = $COLLECTION.findIndex(...);\n              - pattern: |\n                  if ($INDEX === -1) {\n                    return $RES.$STATUS(...);\n                  }\n              - pattern-either:\n                  - pattern: |\n                      const $DELETED = $COLLECTION.splice($INDEX, 1)[0];\n                  - pattern: |\n                      $COLLECTION.splice($INDEX, 1);\n          # 2) Listado de recursos sensibles sin filtrado por propietario/rol\n          - patterns:\n              - pattern: |\n                  if (!$REQ.session.user) {\n                    return $RES.$STATUS(...);\n                  }\n              - pattern-either:\n                  - pattern: |\n                      $RES.json({ $KEY: $COLLECTION });\n                  - pattern: |\n                      $RES.send({ $KEY: $COLLECTION });\n                  - pattern: |\n                      $RES.json($COLLECTION);\n                  - pattern: |\n                      $RES.send($COLLECTION);\n    metadata:\n      cwe: \"CWE-284: Improper Access Control\"\n      owasp: \"A01:2021 - Broken Access Control\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2025-63525\""
  },
  {
    "id": "CVE-2025-63532",
    "reason": "Semgrep Error (Vuln):                \n               \n┌─────────────┐\n│ Scan Status │\n└─────────────┘\n  Scanning 1 file tracked by git with 1 Code rule:\n  Scanning 1 file.\n                \n                \n┌──────────────┐\n│ Scan Summary │\n└──────────────┘\n✅ Scan completed successfully.\n • Findings: 0 (0 blocking)\n • Rules run: 1\n • Targets scanned: 1\n • Parsed lines: ~100.0%\n • No ignore information available\nRan 1 rule on 1 file: 0 findings.\n",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202563532\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible inyección SQL (CVE-2025-63532): se concatena directamente un parámetro\n      controlado por el usuario en una consulta SQL (por ejemplo, req.query.reqid en\n      un UPDATE/DELETE/SELECT). En el Blood Bank Management System (cancel.php?reqid=7),\n      este patrón permitió a un atacante inyectar código SQL (p.ej. \"7 OR 1=1;--\") y\n      obtener acceso no autorizado a la base de datos. Usa consultas preparadas o\n      parámetros enlazados en lugar de concatenar valores.\n    patterns:\n      - pattern-inside: |\n          $DB = require('mysql2');\n          ...\n      - pattern-inside: |\n          $CONN = $DB.$METHOD(...);\n          ...\n      - pattern-either:\n          - pattern: |\n              $CONN.query(`... WHERE ... = ${$USER_INPUT} ...`, ...);\n          - pattern: |\n              $CONN.query(\"... WHERE ... = \" + $USER_INPUT, ...);\n          - pattern: |\n              $SQL = `... WHERE ... = ${$USER_INPUT} ...`;\n              ...\n              $CONN.query($SQL, ...);\n          - pattern: |\n              $SQL = \"...\" + $USER_INPUT + \"...\";\n              ...\n              $CONN.query($SQL, ...);\n      - pattern-either:\n          - pattern-inside: |\n              app.get($ROUTE, ($REQ, $RES, ...) => {\n                ...\n              });\n          - pattern-inside: |\n              app.post($ROUTE, ($REQ, $RES, ...) => {\n                ...\n              });\n      - pattern-either:\n          - pattern-inside: |\n              ... = $REQ.query.$PARAM;\n              ...\n          - pattern-inside: |\n              ... = $REQ.params.$PARAM;\n              ...\n          - pattern-inside: |\n              ... = $REQ.body.$PARAM;\n              ...\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2025-63532\""
  },
  {
    "id": "CVE-2025-63535",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202563535\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-63535): se construye una consulta SQL\n      concatenando directamente datos controlados por el usuario (por ejemplo,\n      req.body.search) en una cadena SQL usada por mysql2/db.query. Un atacante\n      puede inyectar payloads como `'A+' OR '1'='1` para eludir controles de\n      autenticación/búsqueda y acceder o modificar datos sensibles. Usa\n      consultas parametrizadas/prepared statements en lugar de concatenación.\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2025-63535\"\n    patterns:\n      - pattern-inside: |\n          const $DB = require('mysql2');\n          ...\n      - pattern-inside: |\n          $DB.$CREATECONN(...);\n          ...\n      - pattern-either:\n          # mysql2: db.query(sql, ...)\n          - pattern: |\n              $CONN.query($SQL, ...);\n          # mysql2: connection.execute(sql, ...)\n          - pattern: |\n              $CONN.execute($SQL, ...);\n      - pattern: |\n          const $SQL = $Q + $X;\n      - pattern-not: |\n          const $SQL = \"...\";"
  },
  {
    "id": "CVE-2025-37729",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202537729\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible explotación similar a CVE-2025-37729: se está renderizando una plantilla\n      controlada por el usuario mediante Jinjava (u otro motor de plantillas similar)\n      con un contexto amplio que incluye datos sensibles o funciones privilegiadas.\n      Un atacante con capacidad de enviar la plantilla puede leer secretos (por ejemplo\n      claves API, tokens) o invocar funciones administrativas (por ejemplo ece.runAdminCommand),\n      lo que puede derivar en fuga de información y ejecución de acciones críticas.\n    metadata:\n      cwe: \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2025-37729\"\n    patterns:\n      - pattern-inside: |\n          const $JINJAVA = new Jinjava(...);\n          ...\n      - pattern-either:\n          # Caso async/await\n          - pattern: |\n              const $RES = await $JINJAVA.render($TEMPLATE, $CONTEXT);\n          # Caso síncrono\n          - pattern: |\n              const $RES = $JINJAVA.render($TEMPLATE, $CONTEXT);\n      - pattern-inside: |\n          app.$METHOD($ROUTE, ($REQ, $RES, ...$REST) => {\n            ...\n          })\n      - pattern-not: |\n          const $RES = await $JINJAVA.render($TEMPLATE, {});\n      - pattern-not: |\n          const $RES = $JINJAVA.render($TEMPLATE, {});"
  },
  {
    "id": "CVE-2025-55743",
    "reason": "Semgrep Error (Vuln):                \n               \n┌─────────────┐\n│ Scan Status │\n└─────────────┘\n  Scanning 1 file tracked by git with 1 Code rule:\n  Scanning 1 file.\n                \n                \n┌──────────────┐\n│ Scan Summary │\n└──────────────┘\n✅ Scan completed successfully.\n • Findings: 0 (0 blocking)\n • Rules run: 1\n • Targets scanned: 1\n • Parsed lines: ~100.0%\n • No ignore information available\nRan 1 rule on 1 file: 0 findings.\n",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202555743\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible vulnerabilidad similar a CVE-2025-55743: subida de archivos con multer\n      sin validación robusta en el servidor. El código confía en el nombre original\n      y/o en el mimetype controlado por el cliente, y almacena el archivo en una\n      ruta potencialmente pública. Un atacante puede subir contenido arbitrario\n      (por ejemplo, scripts .php, .js o binarios) cambiando extensión y cabeceras,\n      lo que puede derivar en ejecución remota de código, XSS o exposición de datos.\n      Valida el tipo MIME y el contenido real del archivo en el servidor, restringe\n      las extensiones permitidas y evita servir directamente los archivos subidos.\n    patterns:\n      # 1) Detectar configuración de multer.diskStorage con filename basado en file.originalname\n      - pattern-inside: |\n          const $MULTER = require('multer');\n          ...\n      - pattern-either:\n          - patterns:\n              - pattern: |\n                  $STORAGE = $MULTER.diskStorage({\n                    ...\n                    filename: ($REQ, $FILE, $CB) => {\n                      ...\n                      $CB(..., ...$FILE.originalname...);\n                    }\n                    ...\n                  });\n          - patterns:\n              - pattern: |\n                  $STORAGE = $MULTER.diskStorage({\n                    ...\n                    filename: function ($REQ, $FILE, $CB) {\n                      ...\n                      $CB(..., ...$FILE.originalname...);\n                    }\n                    ...\n                  });\n      # 2) Detectar uso de multer con ese storage\n      - pattern-either:\n          - pattern: |\n              const $UPLOAD = $MULTER({ storage: $STORAGE, ... });\n          - pattern: |\n              let $UPLOAD = $MULTER({ storage: $STORAGE, ... });\n          - pattern: |\n              var $UPLOAD = $MULTER({ storage: $STORAGE, ... });\n      # 3) Detectar ruta Express que usa upload.single / upload.array / upload.any\n      - pattern-either:\n          - pattern: |\n              $APP.$METHOD($ROUTE, $UPLOAD.single($FIELD), ($REQ, $RES, ...$REST) => {\n                ...\n              });\n          - pattern: |\n              $APP.$METHOD($ROUTE, $UPLOAD.array($FIELD, ...), ($REQ, $RES, ...$REST) => {\n                ...\n              });\n          - pattern: |\n              $APP.$METHOD($ROUTE, $UPLOAD.any(), ($REQ, $RES, ...$REST) => {\n                ...\n              });\n      # 4) Indicio adicional de confianza en mimetype controlado por el cliente\n      - pattern-either:\n          - pattern: |\n              console.log(...$REQ.file.mimetype...);\n          - pattern: |\n              console.log(...$REQ.files[$IDX].mimetype...);\n          - pattern: |\n              $LOG(...$REQ.file.mimetype...);\n          - pattern: |\n              $LOG(...$REQ.files[$IDX].mimetype...);\n    metadata:\n      cwe: \"CWE-434: Unrestricted Upload of File with Dangerous Type\"\n      owasp: \"A01:2021 - Broken Access Control\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2025-55743\""
  },
  {
    "id": "CVE-2025-57761",
    "reason": "La regla no detectó el código vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202557761\n    languages:\n      - javascript\n      - typescript\n    message: >\n      Posible SQL Injection (CVE-2025-57761): se está construyendo dinámicamente\n      una sentencia SQL DELETE concatenando directamente datos controlados por el\n      usuario (por ejemplo, req.query.id_funcionario) en la consulta. Un atacante\n      puede inyectar código SQL arbitrario (p.ej. \"1 OR 1=1\") y manipular o borrar\n      registros en la base de datos. Usa consultas parametrizadas/preparadas en\n      lugar de concatenar valores en la cadena SQL.\n    severity: ERROR\n    patterns:\n      - pattern-inside: |\n          $DB = require('mysql2');\n          ...\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          });\n      - pattern: |\n          $DB_CONN.query($SQL, ($ERR, $RESULT) => {\n            ...\n          });\n      - pattern: |\n          const $SQL = `DELETE FROM $TABLE WHERE $COL = ${$PARAM}`;\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2025-57761\""
  },
  {
    "id": "CVE-2025-55745",
    "reason": "Semgrep Error (Vuln):                \n               \n┌─────────────┐\n│ Scan Status │\n└─────────────┘\n  Scanning 1 file tracked by git with 1 Code rule:\n  Scanning 1 file.\n                \n                \n┌──────────────┐\n│ Scan Summary │\n└──────────────┘\n✅ Scan completed successfully.\n • Findings: 0 (0 blocking)\n • Rules run: 1\n • Targets scanned: 1\n • Parsed lines: ~100.0%\n • No ignore information available\nRan 1 rule on 1 file: 0 findings.\n",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202555745\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible CSV/Formula Injection (CVE-2025-55745): se están escribiendo\n      datos controlados por el usuario directamente en un archivo CSV que luego\n      es servido como descarga HTTP. Aplicaciones como Excel pueden interpretar\n      celdas que comienzan con \"=\", \"+\", \"-\", \"@\" u otros prefijos peligrosos\n      como fórmulas, permitiendo la ejecución de funciones como HYPERLINK,\n      WEBSERVICE, etc. Esto puede llevar a robo de datos, ejecución de comandos\n      locales o exfiltración cuando el usuario abre el CSV. Sanitiza o\n      escapa los valores antes de escribirlos al CSV (por ejemplo, anteponiendo\n      un apóstrofo o filtrando prefijos peligrosos).\n    metadata:\n      cwe: \"CWE-1236: Improper Neutralization of Formula Elements in a CSV File\"\n      owasp: \"A01:2021 - Broken Access Control\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"MEDIUM\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2025-55745\"\n    patterns:\n      # 1) Estamos dentro de un handler HTTP (Express u otro router similar)\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          })\n      # 2) Se construye un string CSV acumulando filas en una variable\n      - pattern-inside: |\n          let $CSV = $HEADERS;\n          ...\n          $CSV += $ROW;\n          ...\n      # 3) La variable CSV se escribe a disco con fs.writeFile / writeFileSync\n      - pattern-inside: |\n          const $FS = require('fs');\n          ...\n          $FS.writeFile($FILEPATH, $CSV, ...);\n      # 4) El archivo CSV se sirve como descarga HTTP\n      - pattern-inside: |\n          const $PATH = require('path');\n          ...\n          const $FILEPATH = $PATH.join(...);\n          ...\n          $FS.createReadStream($FILEPATH).pipe($RES);\n      # 5) La fila CSV se construye con interpolación de variables potencialmente no sanitizadas\n      - pattern: |\n          $CSV += `${...$PARTS}`;\n      # 6) Excluir casos donde se aplique una sanitización explícita básica para fórmulas\n      - pattern-not: |\n          $CSV += `${...$PARTS}.replace(/^[=+\\-@]/, \"'\")`;"
  }
]