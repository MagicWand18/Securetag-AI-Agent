[
  {
    "id": "CVE-2024-27443",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202427443\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >-\n      Posible XSS reflejado al construir HTML con datos controlados por el usuario (p.ej. req.query/req.body/req.params)\n      mediante template literals o concatenaci\u00f3n y enviarlo como 'text/html' (res.send/res.end). Esto es explotable en\n      escenarios tipo CVE-2024-27443 (inyecci\u00f3n de contenido en UI webmail/calendario), permitiendo ejecutar JavaScript\n      en el navegador de la v\u00edctima. Sanitiza/escapa la salida o usa un motor de plantillas con auto-escape.\n    metadata:\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      owasp: \"A03:2021 - Injection\"\n      category: security\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2024-27443\"\n    patterns:\n      - pattern-inside: |\n          $APP.get($ROUTE, ($REQ, $RES) => {\n            ...\n          })\n      - pattern-either:\n          # Caso 1: template literal con interpolaci\u00f3n de dato no confiable\n          - patterns:\n              - pattern: |\n                  $RES.send(`...${$X}...`)\n              - metavariable-pattern:\n                  metavariable: $X\n                  pattern-either:\n                    - pattern: $REQ.query.$P\n                    - pattern: $REQ.body.$P\n                    - pattern: $REQ.params.$P\n                    - pattern: $REQ.headers[$H]\n                    - pattern: $REQ.get($H)\n          # Caso 2: concatenaci\u00f3n de strings con dato no confiable\n          - patterns:\n              - pattern: |\n                  $RES.send($A + $X + $B)\n              - metavariable-pattern:\n                  metavariable: $X\n                  pattern-either:\n                    - pattern: $REQ.query.$P\n                    - pattern: $REQ.body.$P\n                    - pattern: $REQ.params.$P\n                    - pattern: $REQ.headers[$H]\n                    - pattern: $REQ.get($H)\n          # Caso 3: construir HTML en variable y luego enviarlo\n          - patterns:\n              - pattern: |\n                  $HTML = `...${$X}...`\n              - pattern: |\n                  $RES.send($HTML)\n              - metavariable-pattern:\n                  metavariable: $X\n                  pattern-either:\n                    - pattern: $REQ.query.$P\n                    - pattern: $REQ.body.$P\n                    - pattern: $REQ.params.$P\n                    - pattern: $REQ.headers[$H]\n                    - pattern: $REQ.get($H)\n      # Aumenta precisi\u00f3n: solo cuando se sirve como HTML (como en el ejemplo)\n      - pattern-either:\n          - pattern: |\n              $RES.set('Content-Type', 'text/html; charset=utf-8')\n          - pattern: |\n              $RES.set(\"Content-Type\", \"text/html; charset=utf-8\")\n          - pattern: |\n              $RES.set('Content-Type', 'text/html')\n          - pattern: |\n              $RES.set(\"Content-Type\", \"text/html\")\n          - pattern: |\n              $RES.type('html')\n          - pattern: |\n              $RES.type(\"html\")"
  },
  {
    "id": "CVE-2024-37383",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202437383\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible vulnerabilidad similar a CVE-2024-37383: contenido SVG controlado por el\n      usuario se inserta directamente en una respuesta HTML sin sanitizaci\u00f3n. Esto puede\n      permitir la inyecci\u00f3n de elementos/atributos SVG peligrosos (por ejemplo, <animate>,\n      onbegin, etc.) y conducir a XSS o ejecuci\u00f3n de c\u00f3digo en el navegador. Valida y\n      sanitiza estrictamente cualquier SVG antes de incrustarlo en HTML.\n    patterns:\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          })\n      - pattern: |\n          const $HTML = `\n            ...\n            ${$SVG}\n            ...\n          `;\n      - pattern: |\n          $RES.send($HTML)\n      - pattern-either:\n          - pattern: |\n              $SVG = $REQ.query.$PARAM\n          - pattern: |\n              $SVG = $REQ.body.$PARAM\n          - pattern: |\n              $SVG = $REQ.params.$PARAM\n          - pattern: |\n              $SVG = $REQ.$ANY[$PARAM]\n    metadata:\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2024-37383\""
  },
  {
    "id": "CVE-2024-6670",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve20246670\n    languages:\n      - javascript\n      - typescript\n    message: >\n      Posible inyecci\u00f3n SQL similar a CVE-2024-6670: se construye una consulta SQL\n      concatenando directamente par\u00e1metros controlados por el usuario (por ejemplo,\n      username/password de un endpoint de login) en un SELECT sobre la tabla de\n      usuarios. Un atacante no autenticado puede manipular el valor de estos\n      par\u00e1metros (por ejemplo, con ' OR '1'='1 o UNION SELECT ...) para extraer\n      credenciales cifradas u otros datos sensibles del \u00fanico usuario configurado.\n      Usa siempre consultas parametrizadas/preparadas en lugar de concatenar\n      cadenas SQL.\n    severity: ERROR\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2024-6670\"\n    patterns:\n      # 1) Estamos dentro de un handler HTTP t\u00edpico (Express) que recibe req/res\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          })\n      # 2) Se construye una cadena SQL con template literal o concatenaci\u00f3n\n      #    que contiene un SELECT sobre una tabla de usuarios\n      - pattern-either:\n          - pattern: |\n              const $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $COND`;\n          - pattern: |\n              let $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $COND`;\n          - pattern: |\n              var $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $COND`;\n          - pattern: |\n              const $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $COND;\n          - pattern: |\n              let $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $COND;\n          - pattern: |\n              var $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $COND;\n      # 3) La condici\u00f3n de la cl\u00e1usula WHERE incluye interpolaci\u00f3n directa de\n      #    datos provenientes del cuerpo de la petici\u00f3n (req.body.*),\n      #    t\u00edpico de un login vulnerable.\n      - pattern-either:\n          - pattern: |\n              const $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}' AND $FIELD2 = '${$REQ.body.$PARAM2}'`;\n          - pattern: |\n              let $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}' AND $FIELD2 = '${$REQ.body.$PARAM2}'`;\n          - pattern: |\n              var $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}' AND $FIELD2 = '${$REQ.body.$PARAM2}'`;\n          - pattern: |\n              const $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}'`;\n          - pattern: |\n              let $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}'`;\n          - pattern: |\n              var $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $FIELD = '${$REQ.body.$PARAM}'`;\n          - pattern: |\n              const $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $FIELD + \" = '\" + $REQ.body.$PARAM + \"'\";\n          - pattern: |\n              let $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $FIELD + \" = '\" + $REQ.body.$PARAM + \"'\";\n          - pattern: |\n              var $SQL = \"SELECT \" + $COLUMNS + \" FROM \" + $TABLE + \" WHERE \" + $FIELD + \" = '\" + $REQ.body.$PARAM + \"'\";\n      # 4) La consulta se ejecuta mediante un cliente SQL t\u00edpico de Node.js\n      - pattern-either:\n          - pattern: |\n              $DB.query($SQL, ...);\n          - pattern: |\n              $DB.execute($SQL, ...);\n          - pattern: |\n              $DB.query($SQL, ($ERR, $RESULTS) => {\n                ...\n              });\n          - pattern: |\n              $DB.execute($SQL, ($ERR, $RESULTS) => {\n                ...\n              })"
  },
  {
    "id": "CVE-2023-5631",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3
  },
  {
    "id": "CVE-2023-34362",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202334362\n    languages:\n      - javascript\n      - typescript\n    message: >\n      Posible inyecci\u00f3n SQL no autenticada similar a CVE-2023-34362: se concatena\n      directamente un par\u00e1metro controlado por el usuario en una consulta SQL\n      (`db.query(sql, ...)`) sin usar par\u00e1metros preparados ni escape seguro.\n      Un atacante puede manipular el par\u00e1metro (por ejemplo `?id=1;DROP TABLE users--`)\n      para ejecutar SQL arbitrario, lo que permite acceso o destrucci\u00f3n de datos.\n    severity: ERROR\n    metadata:\n      cve: \"CVE-2023-34362\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology:\n        - nodejs\n        - express\n        - mysql\n      likelihood: \"high\"\n      impact: \"high\"\n      vulnerability_class:\n        - \"SQL Injection\"\n    patterns:\n      - pattern-either:\n          # Caso: template string con interpolaci\u00f3n de variable\n          - pattern: |\n              $DB.$QUERY_FN(`... = ${$PARAM}...`, ...)\n          # Caso: concatenaci\u00f3n con +\n          - pattern: |\n              $DB.$QUERY_FN(\"...\" + $PARAM + \"...\", ...)\n      - pattern-inside: |\n          $DB = require('mysql2');\n          ...\n          $CONN = $DB.$CREATE_CONN(...);\n          ...\n          app.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n            $PARAM = $REQ.$SRC.$FIELD;\n            ...\n            $CONN.$QUERY_FN($SQL, ...);\n            ...\n          });\n      - metavariable-pattern:\n          metavariable: $SRC\n          pattern-either:\n            - pattern: query\n            - pattern: params\n            - pattern: body\n      - metavariable-pattern:\n          metavariable: $QUERY_FN\n          pattern-either:\n            - pattern: query\n            - pattern: execute\n      - metavariable-pattern:\n          metavariable: $CREATE_CONN\n          pattern-either:\n            - pattern: createConnection\n            - pattern: createPool\n      - pattern-not: |\n          $DB.$QUERY_FN($SQL, [$PARAM], ...)"
  },
  {
    "id": "CVE-2020-1956",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3
  },
  {
    "id": "CVE-2009-1151",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve20091151\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible vulnerabilidad similar a CVE-2009-1151: se est\u00e1 generando un archivo\n      PHP de configuraci\u00f3n que incluye directamente datos controlados por el usuario\n      (por ejemplo, desde req.body) dentro de c\u00f3digo PHP. Si un atacante puede\n      inyectar comillas o c\u00f3digo PHP en estos valores, el archivo resultante ser\u00e1\n      interpretado por el int\u00e9rprete PHP, permitiendo ejecuci\u00f3n remota de c\u00f3digo.\n      Valida y escapa estrictamente cualquier dato antes de escribirlo en archivos\n      PHP que luego ser\u00e1n incluidos o ejecutados por el servidor.\n    patterns:\n      - pattern-inside: |\n          fs.writeFile($CONFIG_PATH, $CONTENT, ...)\n      - pattern: |\n          `<?php\n          $... = $...(\n            $... => '${...}',\n            ...\n          );\n          ?>`\n      - pattern-inside: |\n          const $CONTENT = `<?php\n          $... = $...(\n            $... => '${...}',\n            ...\n          );\n          ?>`;\n      - pattern-either:\n          - pattern: |\n              const $REQ = require('express');\n              ...\n              $APP.$METHOD(..., (req, res, ...) => {\n                ...\n                $VAR = req.body.$FIELD || $DEFAULT;\n                ...\n              });\n          - pattern: |\n              $APP.$METHOD(..., (req, res, ...) => {\n                ...\n                $VAR = req.body.$FIELD || $DEFAULT;\n                ...\n              });\n    metadata:\n      cwe: \"CWE-94: Improper Control of Generation of Code ('Code Injection')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2009-1151\""
  },
  {
    "id": "CVE-2021-21315",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3
  },
  {
    "id": "CVE-2025-58745",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558745\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible explotaci\u00f3n de CVE-2025-58745: carga de archivos Excel validando\n      \u00fanicamente el MIME type declarado por el cliente (`file.mimetype`) en\n      `multer.fileFilter`, sin validar extensi\u00f3n ni contenido real. Un atacante\n      puede subir un archivo malicioso (por ejemplo, un webshell `.php`) con\n      magic bytes y/o cabeceras manipuladas para que parezca un Excel y quede\n      accesible o ejecutable en el servidor.\n    metadata:\n      cve: \"CVE-2025-58745\"\n      source: \"CISA_KEV\"\n      category: \"file-upload\"\n      likelihood: \"high\"\n      impact: \"high\"\n      confidence: \"medium\"\n    patterns:\n      - pattern-inside: |\n          const $MULTER = require('multer');\n          ...\n      - pattern-inside: |\n          const $STORAGE = $MULTER.diskStorage({\n            ...\n          });\n      - pattern-inside: |\n          const $UPLOAD = $MULTER({\n            storage: $STORAGE,\n            fileFilter: ($REQ, $FILE, $CB) => {\n              ...\n            }\n          });\n      - pattern: |\n          fileFilter: ($REQ, $FILE, $CB) => {\n            const $ALLOWED = [...];\n            if ($ALLOWED.includes($FILE.mimetype)) {\n              return $CB(null, true);\n            }\n            return $CB(new Error(...));\n          }\n      - pattern-not: |\n          fileFilter: ($REQ, $FILE, $CB) => {\n            ...\n            if ($ALLOWED.includes($FILE.mimetype) && $FILE.originalname.endsWith('.xlsx')) {\n              return $CB(null, true);\n            }\n            ...\n          }"
  },
  {
    "id": "CVE-2025-58453",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558453\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-58453): se construye din\u00e1micamente una consulta SQL\n      concatenando directamente datos controlados por el usuario (por ejemplo, req.query.id_anexo)\n      en la cl\u00e1usula WHERE antes de pasarlos a db.query. Un atacante puede manipular el par\u00e1metro\n      para alterar la consulta, extraer o modificar datos sensibles, o da\u00f1ar la base de datos.\n      Usa consultas parametrizadas/preparadas (placeholders) en lugar de concatenaci\u00f3n de strings.\n    metadata:\n      cve: \"CVE-2025-58453\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql2\"]\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      vulnerability_class: [\"SQL Injection\"]\n    patterns:\n      - pattern-either:\n          # Caso t\u00edpico: template string con interpolaci\u00f3n de variable controlada\n          - pattern: |\n              $DB.$QUERY_FN(`... = ${$USER_INPUT}...`, ...)\n          # Concatenaci\u00f3n con +\n          - pattern: |\n              $DB.$QUERY_FN(\"...\" + $USER_INPUT + \"...\", ...)\n          - pattern: |\n              $DB.$QUERY_FN('...' + $USER_INPUT + '...', ...)\n      - pattern-inside: |\n          const $APP = require('express');\n          ...\n          $APP.$METHOD($ROUTE, ($REQ, $RES, ...$REST) => {\n            ...\n            $USER_INPUT = $REQ.$PROP.$KEY;\n            ...\n          });\n      - pattern-inside: |\n          const $DB = require('mysql2').createConnection(...);\n          ...\n      - pattern-inside: |\n          $DB.$QUERY_FN($SQL, ...);\n      - pattern-not: |\n          $DB.$QUERY_FN($SQL, [$USER_INPUT, ...], ...);\n      - pattern-not: |\n          $DB.$QUERY_FN($SQL, { ... }, ...);"
  },
  {
    "id": "CVE-2025-48208",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202548208\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible LDAP Injection (CVE-2025-48208): se construye un filtro LDAP concatenando\n      directamente datos controlados por el usuario (por ejemplo, `req.body.filter`) en\n      la cadena de b\u00fasqueda (`opts.filter` o par\u00e1metro `filter` de `client.search`).\n      Un atacante autenticado puede inyectar operadores LDAP especiales (`*`, `)`, `(|`, etc.)\n      para alterar la consulta, eludir controles de acceso o extraer informaci\u00f3n sensible.\n      Valida y escapa los valores de entrada antes de construir filtros LDAP o utiliza\n      APIs que manejen par\u00e1metros de forma segura.\n    metadata:\n      cve: CVE-2025-48208\n      source: CISA_KEV\n      category: security\n      technology: [nodejs, express, ldapjs]\n      cwe: \"CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\"\n    patterns:\n      - pattern-either:\n          # Caso 1: filtro se pasa directamente como string concatenado al par\u00e1metro filter de client.search\n          - pattern: |\n              $CLIENT.search($BASE_DN, { ..., filter: $FILTER, ... }, ...);\n          # Caso 2: filtro se pasa como segundo argumento (forma abreviada) a client.search\n          - pattern: |\n              $CLIENT.search($BASE_DN, $FILTER, ...);\n      - pattern-inside: |\n          $CLIENT = require('ldapjs');\n          ...\n      - pattern-inside: |\n          const $APP = require('express')();\n          ...\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ..., (req, res, ... ) => {\n            ...\n          });\n      - pattern-either:\n          # Filtro construido con template string que incluye datos de req.*\n          - pattern: |\n              $FILTER = `...${req.$SRC}...`;\n          - pattern: |\n              $FILTER = `...${req.$SRC.$FIELD}...`;\n          # Filtro construido con concatenaci\u00f3n de strings que incluye datos de req.*\n          - pattern: |\n              $FILTER = \"...\"+req.$SRC+\"...\";\n          - pattern: |\n              $FILTER = \"...\"+req.$SRC.$FIELD+\"...\";\n          - pattern: |\n              $FILTER = req.$SRC + \"...\";\n          - pattern: |\n              $FILTER = req.$SRC.$FIELD + \"...\";\n      - metavariable-pattern:\n          metavariable: $SRC\n          pattern: |\n            body\n      - pattern-not: |\n          $FILTER = $SANITIZE(...);\n      - pattern-not: |\n          $FILTER = $SANITIZE(req.$SRC);\n      - pattern-not: |\n          $FILTER = $SANITIZE(req.$SRC.$FIELD);"
  },
  {
    "id": "CVE-2025-58454",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558454\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-58454): se construye din\u00e1micamente una\n      consulta SQL con datos controlados por el usuario (por ejemplo, req.query.id_memorando)\n      mediante concatenaci\u00f3n/interpolaci\u00f3n de strings antes de pasarlos a mysql2.connection.query().\n      Un atacante puede manipular el par\u00e1metro para alterar la consulta SQL, extraer o modificar datos.\n      Usa consultas parametrizadas/preparadas en lugar de interpolar directamente los valores.\n    metadata:\n      cve: \"CVE-2025-58454\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql2\"]\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n    patterns:\n      - pattern-inside: |\n          const express = require('express');\n          ...\n      - pattern-inside: |\n          $APP = express();\n          ...\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          });\n      - pattern-inside: |\n          $ID = $REQ.query.id_memorando;\n          ...\n      - pattern: |\n          $SQL = `SELECT * FROM $TABLE WHERE id_memorando = ${$ID}`;\n      - pattern-either:\n          - pattern: |\n              $CONN.query($SQL, ...);\n          - pattern: |\n              $CONN.query($SQL, ($ERR, $RESULTS) => {\n                ...\n              });\n    fix: >\n      Usa consultas parametrizadas, por ejemplo:\n      const sql = 'SELECT * FROM despachos WHERE id_memorando = ?';\n      connection.query(sql, [idMemorando], ...);"
  },
  {
    "id": "CVE-2025-58445",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558445\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Exposici\u00f3n de metadatos internos de compilaci\u00f3n y versi\u00f3n a trav\u00e9s de un endpoint p\u00fablico.\n      Esta pr\u00e1ctica facilita el fingerprinting de la aplicaci\u00f3n (nombre del servicio, versi\u00f3n exacta,\n      hash de commit, fecha de build, versi\u00f3n de runtime, SO/arquitectura y dependencias), lo que\n      puede ser aprovechado por un atacante para seleccionar exploits espec\u00edficos o preparar ataques\n      dirigidos (CVE-2025-58445). Limita la informaci\u00f3n expuesta en endpoints de salud/estado a lo\n      estrictamente necesario para monitoreo.\n    patterns:\n      - pattern-either:\n          # Caso 1: objeto buildInfo (o similar) con metadatos internos\n          - pattern: |\n              const $BUILDINFO = {\n                ...\n              };\n          # Caso 2: endpoint Express que expone buildInfo/metadata detallada v\u00eda res.json\n          - pattern: |\n              $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n                ...\n                $RES.json({\n                  ...,\n                  $KEY: $BUILDINFO,\n                  ...\n                });\n              });\n      - pattern-inside: |\n          const $APP = require('express')();\n          ...\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          });\n      - metavariable-pattern:\n          metavariable: $ROUTE\n          pattern: |\n            '/status'\n    metadata:\n      cve: CVE-2025-58445\n      source: CISA_KEV\n      category: security\n      technology:\n        - express\n      references:\n        - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-58445\n      description: >\n        Detecci\u00f3n de endpoints de estado/health en aplicaciones Express que exponen metadatos\n        internos de build y versi\u00f3n (buildInfo) de forma p\u00fablica, facilitando el fingerprinting\n        y la selecci\u00f3n de exploits dirigidos."
  },
  {
    "id": "CVE-2025-9941",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve20259941\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible carga de archivos insegura asociada a CVE-2025-9941: se usa\n      `multer.diskStorage` para guardar archivos subidos en un directorio\n      accesible p\u00fablicamente usando `file.originalname` como nombre final,\n      sin validaci\u00f3n de tipo, tama\u00f1o o extensi\u00f3n. Un atacante puede subir\n      archivos maliciosos (por ejemplo, scripts ejecutables) y acceder a\n      ellos directamente v\u00eda HTTP, lo que puede derivar en ejecuci\u00f3n de\n      c\u00f3digo, defacement o exfiltraci\u00f3n de datos. Valida estrictamente el\n      tipo de archivo, tama\u00f1o, extensi\u00f3n y evita usar el nombre original\n      del archivo en rutas p\u00fablicas.\n    metadata:\n      cve: \"CVE-2025-9941\"\n      source: \"CISA_KEV\"\n      category: security\n      technology:\n        - express\n        - nodejs\n        - multer\n    patterns:\n      - pattern-either:\n          # Patr\u00f3n 1: configuraci\u00f3n de diskStorage con destino en carpeta p\u00fablica y uso de originalname\n          - pattern: |\n              const $M = require('multer');\n              ...\n              const $STORAGE = $M.diskStorage({\n                destination: function ($REQ, $FILE, $CB) {\n                  $CB(null, $DEST);\n                },\n                filename: function ($REQ2, $FILE2, $CB2) {\n                  $CB2(null, $FILE2.originalname);\n                }\n              });\n          # Patr\u00f3n 2: uso de multer.diskStorage con filename basado en originalname (forma m\u00e1s gen\u00e9rica)\n          - pattern: |\n              $MULTER.diskStorage({\n                ...\n                filename: function ($REQ, $FILE, $CB) {\n                  $CB(..., $FILE.originalname);\n                }\n              })\n      # Debe existir un uso de `upload.single(...)` o similar en una ruta Express (indica endpoint de subida)\n      - pattern-either:\n          - pattern: |\n              $APP.post($ROUTE, $UPLOAD.single($FIELD), ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $APP.post($ROUTE, $UPLOAD.single($FIELD), function ($REQ, $RES) {\n                ...\n              })\n          - pattern: |\n              $APP.$METHOD($ROUTE, $UPLOAD.single($FIELD), ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $APP.$METHOD($ROUTE, $UPLOAD.single($FIELD), function ($REQ, $RES) {\n                ...\n              })\n    fix: >\n      No uses `file.originalname` directamente como nombre final ni guardes\n      archivos subidos en rutas p\u00fablicas sin validaci\u00f3n. Genera nombres\n      aleatorios seguros, aplica filtros de tipo MIME/extensi\u00f3n, l\u00edmites de\n      tama\u00f1o y, si es posible, almacena los archivos fuera del \u00e1rbol\n      p\u00fablico de la aplicaci\u00f3n."
  },
  {
    "id": "CVE-2025-10012",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202510012\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-10012-like): se construye din\u00e1micamente\n      una consulta SQL concatenando directamente datos controlados por el\n      usuario (por ejemplo, req.query.ref_cod_aluno) en la cadena de consulta\n      antes de pasarlos a db.query(). Un atacante puede manipular el par\u00e1metro\n      para alterar la consulta SQL, extraer o modificar datos sensibles o\n      comprometer la base de datos. Use consultas parametrizadas/preparadas\n      (placeholders) en lugar de concatenaci\u00f3n de strings.\n    metadata:\n      cve: \"CVE-2025-10012\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql2\"]\n      vulnerability: \"sql-injection\"\n    patterns:\n      - pattern-either:\n          # Caso 1: template string con interpolaci\u00f3n de variable controlada\n          - pattern: |\n              $DB.$QUERY_FN(`... = ${$USER_INPUT} ...`, ...)\n          # Caso 2: concatenaci\u00f3n cl\u00e1sica con +\n          - pattern: |\n              $DB.$QUERY_FN(\"...\" + $USER_INPUT + \"...\", ...)\n      - pattern-inside: |\n          app.$ROUTE_METHOD($ROUTE, ($REQ, $RES, ...) => {\n            ...\n          })\n      - pattern-inside: |\n          const $USER_INPUT = $REQ.query.$PARAM;\n      - pattern-inside: |\n          const $DB = require('mysql2').createConnection(...);\n      - metavariable-regex:\n          metavariable: $QUERY_FN\n          regex: ^(query|execute|executeQuery|raw|run)$\n      - metavariable-regex:\n          metavariable: $ROUTE_METHOD\n          regex: ^(get|post|put|delete|patch|all|use)$"
  },
  {
    "id": "CVE-2025-10098",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202510098\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-10098): se construye din\u00e1micamente una\n      consulta SQL concatenando o interpolando datos controlados por el usuario\n      (por ejemplo, par\u00e1metros de `req.body`, `req.query` o similares) en la\n      cadena de consulta pasada a `db.query`/`connection.query` de `mysql`. Un\n      atacante puede manipular estos valores para alterar la consulta SQL,\n      exfiltrar datos o escalar privilegios. Usa consultas parametrizadas\n      (placeholders `?` o bindings) en lugar de concatenar/interpolar valores\n      directamente en la cadena SQL.\n    metadata:\n      cve: \"CVE-2025-10098\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql\"]\n      vulnerability: \"sql-injection\"\n    patterns:\n      - pattern-either:\n          # mysql / mysql2 style: db.query(sql, ...)\n          - pattern: |\n              $DB.query($SQL, ...);\n          # connection.query(sql, ...)\n          - pattern: |\n              $CONN.query($SQL, ...);\n      - pattern-either:\n          # SQL construido con template literal que incluye valores no constantes\n          - pattern: |\n              const $SQL = `$X${...}$Y`;\n          - pattern: |\n              let $SQL = `$X${...}$Y`;\n          - pattern: |\n              var $SQL = `$X${...}$Y`;\n          # SQL construido por concatenaci\u00f3n con +\n          - pattern: |\n              const $SQL = $X + $Y;\n          - pattern: |\n              let $SQL = $X + $Y;\n          - pattern: |\n              var $SQL = $X + $Y;\n      - pattern-either:\n          # Origen t\u00edpico de datos controlados por el usuario en Express\n          - pattern: |\n              $SRC = $REQ.body.$FIELD;\n          - pattern: |\n              $SRC = $REQ.query.$FIELD;\n          - pattern: |\n              $SRC = $REQ.params.$FIELD;\n          - pattern: |\n              $SRC = $REQ.headers[$H];\n      - pattern-either:\n          # El valor controlado por el usuario se usa en la construcci\u00f3n del SQL\n          - pattern: |\n              const $SQL = ... $SRC ...;\n          - pattern: |\n              let $SQL = ... $SRC ...;\n          - pattern: |\n              var $SQL = ... $SRC ...;\n          - pattern: |\n              $SQL = ... $SRC ...;\n      - pattern-not: |\n          // Exclusi\u00f3n b\u00e1sica de consultas parametrizadas con placeholders\n          $DB.query($SQL, [...]);\n      - pattern-not: |\n          // Exclusi\u00f3n b\u00e1sica de consultas parametrizadas con objeto de par\u00e1metros\n          $DB.query($SQL, {...});\n    fix: >\n      Usa consultas parametrizadas. Por ejemplo:\n      `const sql = \"UPDATE users SET full_name = ?, email = ? WHERE id = ?\"; db.query(sql, [fullName, email, uid]);`"
  },
  {
    "id": "CVE-2025-57819",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202557819\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible bypass de autenticaci\u00f3n de administrador y ejecuci\u00f3n de SQL arbitrario\n      similar a CVE-2025-57819: se usa un valor controlado por el usuario (cabecera,\n      cookie o cuerpo de la petici\u00f3n) para construir una consulta SQL de autenticaci\u00f3n\n      mediante concatenaci\u00f3n de strings, y si existe cualquier fila se considera\n      al usuario como administrador. Luego, en un endpoint privilegiado (por ejemplo\n      /admin o similar), se ejecuta directamente una sentencia SQL arbitraria\n      proporcionada por el cliente (p.ej. req.body.rawSql) con pool.query/rawQuery.\n      Esto permite a un atacante eludir la autenticaci\u00f3n y ejecutar comandos SQL\n      arbitrarios en la base de datos, pudiendo derivar en RCE en entornos similares\n      al descrito en CVE-2025-57819.\n    metadata:\n      cwe: \"CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2025-57819\"\n    patterns:\n      # 1) Funci\u00f3n de autenticaci\u00f3n insegura basada en token/cabecera/cookie\n      - pattern-inside: |\n          async function $FUNC($REQ, ...) {\n            ...\n          }\n      - pattern-either:\n          - pattern: |\n              const $RAW = $REQ.headers[$KEY] || ...;\n          - pattern: |\n              const $RAW = $REQ.cookies[$KEY] || ...;\n          - pattern: |\n              const $RAW = $REQ.body[$KEY] || ...;\n      - pattern: |\n          const $SQL = `SELECT $COLUMNS FROM $TABLE WHERE $COL = '${$RAW}'`;\n      - pattern: |\n          const [$ROWS] = await $POOL.query($SQL);\n      - pattern: |\n          if ($ROWS.length === 0) {\n            return false;\n          }\n      - pattern: |\n          return true;\n\n      # 2) Endpoint \"admin\" que llama a la funci\u00f3n anterior y ejecuta SQL arbitrario del body\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, async ($REQ2, $RES, ...) => {\n            ...\n          })\n      - pattern-either:\n          - pattern: |\n              $APP.post($ROUTE, async ($REQ2, $RES, ...) => {\n                ...\n              })\n          - pattern: |\n              $APP.get($ROUTE, async ($REQ2, $RES, ...) => {\n                ...\n              })\n      - pattern: |\n          const $ISADMIN = await $FUNC($REQ2);\n      - pattern: |\n          if (!$ISADMIN) {\n            return $RES.status(401).json(...);\n          }\n      - pattern: |\n          const { $RAWSQL } = $REQ2.body;\n      - pattern-either:\n          - pattern: |\n              await $POOL.query($RAWSQL);\n          - pattern: |\n              $POOL.query($RAWSQL);"
  },
  {
    "id": "CVE-2024-42009",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202442009\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible vulnerabilidad tipo CVE-2024-42009: contenido HTML controlado por un atacante\n      se devuelve o propaga como \"ya sanitizado\" y luego se inserta directamente en una\n      respuesta HTML (por ejemplo, con res.send) sin escape ni sanitizaci\u00f3n adicional.\n      Esto permite XSS almacenado o reflejado cuando el HTML se muestra en el navegador.\n      Aseg\u00farate de escapar/sanitizar el contenido antes de interpolarlo en la respuesta\n      o usa APIs que hagan escape autom\u00e1tico.\n    metadata:\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2024-42009\"\n    patterns:\n      # 1) Detectamos una funci\u00f3n que act\u00faa como \"desanitizadora\" o passthrough de HTML\n      - pattern: |\n          function $FNAME($ARG, ...) {\n            ...\n            return $ARG;\n          }\n      # 2) Dentro del handler de Express, se llama a esa funci\u00f3n con datos potencialmente controlados\n      #    por el usuario (req.query, req.body, req.params, etc.)\n      - pattern-inside: |\n          app.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          })\n      - pattern: |\n          $BODY = $FNAME($USER_INPUT);\n      - pattern-either:\n          - pattern: $USER_INPUT = $REQ.query.$FIELD;\n          - pattern: $USER_INPUT = $REQ.query[$FIELD];\n          - pattern: $USER_INPUT = $REQ.body.$FIELD;\n          - pattern: $USER_INPUT = $REQ.body[$FIELD];\n          - pattern: $USER_INPUT = $REQ.params.$FIELD;\n          - pattern: $USER_INPUT = $REQ.params[$FIELD];\n          - pattern: $USER_INPUT = $REQ.$ANYPROP;\n      # 3) El resultado de esa \"desanitizaci\u00f3n\" se inserta directamente en una plantilla HTML\n      #    enviada con res.send, usando interpolaci\u00f3n de template string (${...})\n      - pattern-inside: |\n          $RES.send(`$HTML`);\n      - pattern: |\n          $RES.send(`...${$BODY}...`)"
  },
  {
    "id": "CVE-2024-11182",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202411182\n    languages:\n      - javascript\n      - typescript\n    message: >\n      Posible XSS almacenado/reflejado similar a CVE-2024-11182: contenido HTML de correo\n      (`rawEmailHtml` u otra variable) se inserta directamente en la respuesta HTML de Express\n      mediante `res.send()` sin sanitizaci\u00f3n ni escape. Un atacante puede inyectar `<script>`\n      u otras cargas maliciosas que se ejecutar\u00e1n en el navegador del usuario. Valida o\n      sanitiza el HTML antes de insertarlo en la respuesta.\n    severity: ERROR\n    metadata:\n      cwe: \"CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\"\n      owasp: \"A03:2021 - Injection\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2024-11182\"\n    patterns:\n      - pattern-inside: |\n          app.$ROUTE($PATH, ($REQ, $RES) => {\n            ...\n          })\n      - pattern: |\n          $RES.setHeader(\"Content-Type\", \"text/html\" , ...);\n      - pattern: |\n          $RES.send(`...${$UNTRUSTED}...`);\n      - pattern-not: |\n          $RES.send(`...${sanitize($UNTRUSTED)}...`);\n      - pattern-not: |\n          $RES.send(`...${escape($UNTRUSTED)}...`);\n      - pattern-not: |\n          $RES.send(`...${$SANITIZER($UNTRUSTED)}...`)"
  },
  {
    "id": "CVE-2021-20123",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202120123\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >-\n      Posible Path Traversal (CVE-2021-20123): se construye una ruta de archivo a\n      partir de entrada controlada por el usuario (p.ej., req.query/req.params/req.body)\n      y luego se lee el archivo (fs.readFile / readFileSync / createReadStream) sin\n      validar que la ruta resultante permanezca dentro de un directorio base. Esto\n      permite usar secuencias como \"../\" para acceder a archivos arbitrarios y es\n      altamente explotable (probabilidad 94%).\n    metadata:\n      cwe: \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n      owasp: \"A01:2021 - Broken Access Control\"\n      category: security\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2021-20123\"\n    pattern-either:\n      # Caso t\u00edpico: path.join(baseDir, userInput) -> fs.readFile(...)\n      - patterns:\n          - pattern-inside: |\n              $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $TARGET = $PATH.join($BASE, $USER_INPUT)\n          - metavariable-regex:\n              metavariable: $USER_INPUT\n              regex: ^(\\$REQ\\.(query|params|body)(\\.[A-Za-z0-9_$]+)?|\\$REQ\\[['\"](query|params|body)['\"]\\](\\[[^\\]]+\\])?)$\n          - pattern-either:\n              - pattern: $FS.readFile($TARGET, ...)\n              - pattern: $FS.readFileSync($TARGET, ...)\n              - pattern: $FS.createReadStream($TARGET, ...)\n              - pattern: $FS.open($TARGET, ...)\n              - pattern: $FS.openSync($TARGET, ...)\n          - pattern-not: |\n              if (!$TARGET.startsWith($BASE)) { ... }\n\n      # Variante: path.resolve(baseDir, userInput) -> fs.readFile(...)\n      - patterns:\n          - pattern-inside: |\n              $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $TARGET = $PATH.resolve($BASE, $USER_INPUT)\n          - metavariable-regex:\n              metavariable: $USER_INPUT\n              regex: ^(\\$REQ\\.(query|params|body)(\\.[A-Za-z0-9_$]+)?|\\$REQ\\[['\"](query|params|body)['\"]\\](\\[[^\\]]+\\])?)$\n          - pattern-either:\n              - pattern: $FS.readFile($TARGET, ...)\n              - pattern: $FS.readFileSync($TARGET, ...)\n              - pattern: $FS.createReadStream($TARGET, ...)\n              - pattern: $FS.open($TARGET, ...)\n              - pattern: $FS.openSync($TARGET, ...)\n          - pattern-not: |\n              if (!$TARGET.startsWith($BASE)) { ... }\n\n      # Caso directo: fs.readFile(path.join(baseDir, userInput), ...)\n      - patterns:\n          - pattern-inside: |\n              $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n                ...\n              })\n          - pattern-either:\n              - pattern: $FS.readFile($PATH.join($BASE, $USER_INPUT), ...)\n              - pattern: $FS.readFileSync($PATH.join($BASE, $USER_INPUT), ...)\n              - pattern: $FS.createReadStream($PATH.join($BASE, $USER_INPUT), ...)\n              - pattern: $FS.open($PATH.join($BASE, $USER_INPUT), ...)\n              - pattern: $FS.openSync($PATH.join($BASE, $USER_INPUT), ...)\n              - pattern: $FS.readFile($PATH.resolve($BASE, $USER_INPUT), ...)\n              - pattern: $FS.readFileSync($PATH.resolve($BASE, $USER_INPUT), ...)\n              - pattern: $FS.createReadStream($PATH.resolve($BASE, $USER_INPUT), ...)\n              - pattern: $FS.open($PATH.resolve($BASE, $USER_INPUT), ...)\n              - pattern: $FS.openSync($PATH.resolve($BASE, $USER_INPUT), ...)\n          - metavariable-regex:\n              metavariable: $USER_INPUT\n              regex: ^(\\$REQ\\.(query|params|body)(\\.[A-Za-z0-9_$]+)?|\\$REQ\\[['\"](query|params|body)['\"]\\](\\[[^\\]]+\\])?)$"
  },
  {
    "id": "CVE-2023-36847",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202336847\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible carga de archivos arbitrarios sin autenticaci\u00f3n ni validaci\u00f3n,\n      similar a CVE-2023-36847 (Juniper J-Web installAppPackage.php). Un\n      endpoint que acepta archivos mediante multer.diskStorage sin validar\n      tipo, tama\u00f1o ni nombre (usando file.originalname directamente) puede\n      permitir a un atacante subir paquetes maliciosos o ejecutar c\u00f3digo\n      arbitrario en el servidor.\n    metadata:\n      cwe: \"CWE-434: Unrestricted Upload of File with Dangerous Type\"\n      owasp: \"A05:2021 - Security Misconfiguration\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2023-36847\"\n    patterns:\n      # 1) Uso de multer.diskStorage\n      - pattern-inside: |\n          const $MULTER = require('multer');\n          ...\n      - pattern: |\n          $STORAGE = $MULTER.diskStorage({\n            destination: ($REQ, $FILE, $CB) => {\n              $CB(null, $DEST);\n            },\n            filename: ($REQ2, $FILE2, $CB2) => {\n              $CB2(null, $FILE2.originalname);\n            },\n          });\n      # 2) Uso de ese storage en configuraci\u00f3n de multer\n      - pattern: |\n          $UPLOAD = $MULTER({ storage: $STORAGE, ... });\n      # 3) Endpoint HTTP que usa upload.single(...) sin validaciones adicionales\n      - pattern-either:\n          - pattern: |\n              $APP.post($ROUTE, $UPLOAD.single($FIELD), ($REQ3, $RES3) => {\n                ...\n              });\n          - pattern: |\n              $ROUTER.post($ROUTE, $UPLOAD.single($FIELD), ($REQ3, $RES3) => {\n                ...\n              });"
  },
  {
    "id": "CVE-2016-3976",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve20163976\n    languages:\n      - javascript\n      - typescript\n    severity: ERROR\n    message: >\n      Posible vulnerabilidad de directory traversal similar a CVE-2016-3976:\n      se concatena directamente un par\u00e1metro controlado por el usuario a una\n      ruta base (por ejemplo, BASE_DIR) y se usa en operaciones de lectura de\n      archivos (fs.readFile / fs.readFileSync / fs.createReadStream) sin\n      validar que la ruta resultante permanezca dentro del directorio esperado.\n      Un atacante puede usar secuencias como \"../\" o \"..\\\" para escapar del\n      directorio y leer archivos arbitrarios. Valida y normaliza la ruta antes\n      de usarla o restringe expl\u00edcitamente el acceso a un directorio seguro.\n    patterns:\n      - pattern-inside: |\n          const $FS = require('fs');\n          ...\n      - pattern-inside: |\n          $FS.$READFUNC($FILEPATH, ...);\n      - pattern-either:\n          - pattern: |\n              $FILEPATH = require('path').join($BASEDIR, $USERINPUT);\n          - pattern: |\n              $FILEPATH = $PATHMOD.join($BASEDIR, $USERINPUT);\n      - pattern-not: |\n          $FILEPATH = $PATHMOD.join($BASEDIR, $USERINPUT);\n          if (!$FILEPATH.startsWith($BASEDIR)) {\n            ...\n          }\n      - pattern-not: |\n          $FILEPATH = $PATHMOD.join($BASEDIR, $USERINPUT);\n          if (!$FILEPATH.includes('..')) {\n            ...\n          }\n    metadata:\n      cwe: \"CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\"\n      owasp: \"A01:2021 - Broken Access Control\"\n      category: \"security\"\n      technology:\n        - javascript\n        - typescript\n        - nodejs\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2016-3976\""
  }
]