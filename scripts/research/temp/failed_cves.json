[
  {
    "id": "CVE-2024-27443",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202427443\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible XSS almacenado/reflejado en generaci\u00f3n de HTML a partir de datos\n      de invitaciones de calendario sin escape ni sanitizaci\u00f3n. Datos controlados\n      por el usuario (por ejemplo, organizer, subject, location, description,\n      startTime, endTime) provenientes de req.body se interpolan directamente en\n      una plantilla HTML enviada con Content-Type text/html. Esto permite a un\n      atacante inyectar c\u00f3digo JavaScript malicioso (por ejemplo, en el campo\n      subject con <img src=x onerror=\"...\">), similar al escenario descrito en\n      CVE-2024-27443, con alta probabilidad de explotaci\u00f3n (32.3%).\n    metadata:\n      cve: \"CVE-2024-27443\"\n      source: \"CISA_KEV\"\n      category: security\n      technology: [express, nodejs]\n      cwe: \"CWE-79\"\n    patterns:\n      - pattern-inside: |\n          app.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          })\n      - pattern-inside: |\n          const $HTML = `\n            ...\n          `;\n          ...\n          $RES.setHeader('Content-Type', 'text/html' , ...);\n          ...\n          $RES.send($HTML);\n      - pattern-either:\n          - pattern: |\n              const $HTML = `\n                ...\n                ${$REQ.body.$FIELD}\n                ...\n              `;\n          - pattern: |\n              const $HTML = `\n                ...\n                ${$REQ.$PROP.$FIELD}\n                ...\n              `;\n    fix: >\n      Escapa o sanitiza todos los valores provenientes de req.body antes de\n      interpolarlos en HTML (por ejemplo, usando una funci\u00f3n de escape de HTML o\n      una librer\u00eda de plantillas segura) o utiliza un motor de plantillas que\n      haga escape autom\u00e1tico del contenido."
  },
  {
    "id": "CVE-2024-37383",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202437383\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible XSS al incrustar contenido SVG controlado por el usuario directamente en HTML\n      sin sanitizaci\u00f3n. Esto es similar a CVE-2024-37383, donde atributos SVG como\n      <animate> pueden abusarse para ejecutar JavaScript (por ejemplo, usando atributos\n      de evento como onbegin). Valida/escapa el SVG o usa una librer\u00eda de sanitizaci\u00f3n\n      antes de insertarlo en la respuesta HTML.\n    metadata:\n      cve: CVE-2024-37383\n      source: CISA_KEV\n      category: security\n      technology: [nodejs, express]\n      vulnerability: xss\n      likelihood_of_exploit: HIGH\n    patterns:\n      # 1) Detectar uso de Express y un handler de ruta\n      - pattern-either:\n          - pattern: |\n              $APP.get($ROUTE, ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $APP.get($ROUTE, function ($REQ, $RES) {\n                ...\n              })\n      # 2) Dentro del handler, detectar que un valor derivado de req.* se usa en una plantilla HTML\n      - pattern: |\n          $APP.get($ROUTE, $HANDLER) \n      - pattern-inside: |\n          $APP.get($ROUTE, ($REQ, $RES) => {\n            ...\n            $USER_SVG = $REQ.$ANY1.$ANY2 || $FALLBACK;\n            ...\n            $HTML = `...`;\n            ...\n            $RES.$SEND($HTML);\n          })\n      # 3) Asegurar que la variable controlada por el usuario se inserta sin escapar en la template literal\n      - pattern-regex: '\\$\\{\\s*\\$USER_SVG\\s*\\}'\n      # 4) Asegurar que la template literal parece ser HTML (para reducir falsos positivos)\n      - pattern-regex: '<html[> ]|<!DOCTYPE html>|<body[> ]'\n      # 5) Asegurar que el contenido se env\u00eda como HTML\n      - pattern-either:\n          - pattern-inside: |\n              $RES.setHeader('Content-Type', 'text/html' ...);\n              ...\n              $RES.$SEND($HTML);\n          - pattern-inside: |\n              $RES.set('Content-Type', 'text/html' ...);\n              ...\n              $RES.$SEND($HTML);"
  },
  {
    "id": "CVE-2024-6670",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve20246670\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection relacionado con CVE-2024-6670: se construye una consulta SQL\n      concatenando directamente datos controlados por el usuario (por ejemplo, req.query,\n      req.body, req.params) en una cadena SQL antes de pasarlos a db.query / connection.query.\n      Esto permite a un atacante inyectar cl\u00e1usulas como ' OR '1'='1' UNION SELECT ... para\n      extraer credenciales o datos sensibles, especialmente en endpoints sin autenticaci\u00f3n.\n      Usa consultas parametrizadas / placeholders en lugar de concatenaci\u00f3n de strings.\n    metadata:\n      cve: \"CVE-2024-6670\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology:\n        - nodejs\n        - express\n        - mysql\n      likelihood: \"high\"\n      impact: \"high\"\n      references:\n        - \"https://nvd.nist.gov/vuln/detail/CVE-2024-6670\"\n      vulnerability_class:\n        - \"SQL Injection\"\n    patterns:\n      - pattern-either:\n          # mysql2 / mysql style\n          - pattern: |\n              $DB = require('mysql2');\n              ...\n              $CONN = $DB.createConnection(...);\n              ...\n              $CONN.query($SQL, ...);\n          - pattern: |\n              $DB = require('mysql');\n              ...\n              $CONN = $DB.createConnection(...);\n              ...\n              $CONN.query($SQL, ...);\n          - pattern: |\n              import $DB from 'mysql2';\n              ...\n              const $CONN = $DB.createConnection(...);\n              ...\n              $CONN.query($SQL, ...);\n          - pattern: |\n              import $DB from 'mysql';\n              ...\n              const $CONN = $DB.createConnection(...);\n              ...\n              $CONN.query($SQL, ...);\n      - pattern: |\n          $SQL = $Q1 + $USER + $Q2;\n      - pattern-either:\n          - pattern: |\n              $USER = req.query[$KEY];\n          - pattern: |\n              $USER = req.query.$KEY;\n          - pattern: |\n              $USER = req.body[$KEY];\n          - pattern: |\n              $USER = req.body.$KEY;\n          - pattern: |\n              $USER = req.params[$KEY];\n          - pattern: |\n              $USER = req.params.$KEY;\n      - pattern-inside: |\n          app.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          });\n    fix: >\n      Usa consultas parametrizadas, por ejemplo:\n      const sql = \"SELECT id, username, encrypted_password FROM users WHERE username = ?\";\n      db.query(sql, [username], ...);"
  },
  {
    "id": "CVE-2023-5631",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3
  },
  {
    "id": "CVE-2023-34362",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202334362\n    languages:\n      - javascript\n      - typescript\n    message: >\n      Posible inyecci\u00f3n SQL no autenticada similar a CVE-2023-34362: se concatena\n      directamente un par\u00e1metro controlado por el usuario en una consulta SQL\n      (`db.query(sql, ...)`) sin usar par\u00e1metros preparados ni escape seguro.\n      Un atacante puede manipular el par\u00e1metro (por ejemplo `?id=1;DROP TABLE users--`)\n      para ejecutar SQL arbitrario, lo que permite acceso o destrucci\u00f3n de datos.\n    severity: ERROR\n    metadata:\n      cve: \"CVE-2023-34362\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology:\n        - nodejs\n        - express\n        - mysql\n      likelihood: \"high\"\n      impact: \"high\"\n      vulnerability_class:\n        - \"SQL Injection\"\n    patterns:\n      - pattern-either:\n          # Caso: template string con interpolaci\u00f3n de variable\n          - pattern: |\n              $DB.$QUERY_FN(`... = ${$PARAM}...`, ...)\n          # Caso: concatenaci\u00f3n con +\n          - pattern: |\n              $DB.$QUERY_FN(\"...\" + $PARAM + \"...\", ...)\n      - pattern-inside: |\n          $DB = require('mysql2');\n          ...\n          $CONN = $DB.$CREATE_CONN(...);\n          ...\n          app.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n            $PARAM = $REQ.$SRC.$FIELD;\n            ...\n            $CONN.$QUERY_FN($SQL, ...);\n            ...\n          });\n      - metavariable-pattern:\n          metavariable: $SRC\n          pattern-either:\n            - pattern: query\n            - pattern: params\n            - pattern: body\n      - metavariable-pattern:\n          metavariable: $QUERY_FN\n          pattern-either:\n            - pattern: query\n            - pattern: execute\n      - metavariable-pattern:\n          metavariable: $CREATE_CONN\n          pattern-either:\n            - pattern: createConnection\n            - pattern: createPool\n      - pattern-not: |\n          $DB.$QUERY_FN($SQL, [$PARAM], ...)"
  },
  {
    "id": "CVE-2020-1956",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3
  },
  {
    "id": "CVE-2009-1151",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve20091151\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible generaci\u00f3n de archivo PHP con contenido controlado por el usuario\n      (similar a CVE-2009-1151). Datos provenientes de la petici\u00f3n HTTP se\n      interpolan directamente en una plantilla PHP que luego se escribe a disco.\n      Si el archivo es servido por el int\u00e9rprete PHP, un atacante puede inyectar\n      c\u00f3digo PHP arbitrario (por ejemplo, usando valores como `\"; phpinfo(); //`)\n      y lograr ejecuci\u00f3n remota de c\u00f3digo. Valida, escapa o evita generar c\u00f3digo\n      ejecutable a partir de entrada de usuario.\n    metadata:\n      cve: \"CVE-2009-1151\"\n      source: \"CISA_KEV\"\n      category: \"code-injection\"\n      technology: [\"nodejs\", \"express\", \"php\"]\n    patterns:\n      # 1) Identificar un handler HTTP t\u00edpico de Express que recibe req/res\n      - pattern-either:\n          - pattern: |\n              $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $APP.$METHOD($ROUTE, function ($REQ, $RES) {\n                ...\n              })\n      # 2) Dentro del handler, construir una cadena que empiece con \"<?php\"\n      #    y contenga interpolaci\u00f3n de variables (template literal)\n      - pattern: |\n          const $CONF = `<?php\n          ... $INTERP ...\n          `;\n      # 3) Asegurar que la variable interpolada proviene de la petici\u00f3n (req.body / req.query / req.params)\n      - pattern-either:\n          - pattern: |\n              const $INTERP = $REQ.body.$FIELD || ...;\n          - pattern: |\n              const $INTERP = $REQ.query.$FIELD || ...;\n          - pattern: |\n              const $INTERP = $REQ.params.$FIELD || ...;\n      # 4) El contenido PHP generado se escribe a disco\n      - pattern-either:\n          - pattern: fs.writeFile($PATH, $CONF, ...);\n          - pattern: fs.writeFileSync($PATH, $CONF, ...);\n      # 5) El archivo destino aparenta ser un script PHP\n      - pattern: |\n          $PATH = path.join(..., \"config.php\");\n    fix: >\n      No generes archivos PHP a partir de entrada de usuario. Si necesitas\n      configuraci\u00f3n din\u00e1mica, almac\u00e9nala en formatos de datos (JSON, YAML, env)\n      y no en c\u00f3digo ejecutable. Si no puedes evitarlo, aplica una lista blanca\n      estricta y escapa/valida exhaustivamente todos los valores antes de\n      escribirlos."
  },
  {
    "id": "CVE-2021-21315",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3
  },
  {
    "id": "CVE-2020-10221",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202010221\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible inyecci\u00f3n de comandos del sistema operativo (OS Command Injection)\n      relacionada con CVE-2020-10221: se construye un comando de shell concatenando\n      directamente datos controlados por el usuario (por ejemplo, par\u00e1metros de\n      request) en una cadena que se pasa a child_process.exec. Un atacante puede\n      inyectar metacaracteres de shell (como `;`, `&&`, `|`) y ejecutar comandos\n      arbitrarios con los privilegios del proceso. Valida/escapa estrictamente la\n      entrada o usa APIs que no invoquen un shell (por ejemplo, execFile/spawn con\n      argumentos separados).\n    metadata:\n      cve: \"CVE-2020-10221\"\n      source: \"CISA_KEV\"\n      category: security\n      technology: [nodejs, express]\n      owasp:\n        - A03:2021 - Injection\n      cwe:\n        - \"CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\"\n    patterns:\n      - pattern-either:\n          # Caso 1: comando construido con template string que incluye datos de request\n          - pattern: |\n              $CP.exec(`$CMD${...$REST}`, ...);\n          - pattern: |\n              $CP.exec(`...${$USER}...`, ...);\n          - pattern: |\n              $CP.exec($CMD, ...);\n      - pattern-inside: |\n          const $CP = require('child_process');\n          ...\n      - pattern-either:\n          # Origen t\u00edpico de datos controlados por el usuario en Express\n          - pattern-inside: |\n              app.$METHOD(..., (req, res, ...) => {\n                ...\n              });\n          - pattern-inside: |\n              $ROUTER.$METHOD(..., (req, res, ...) => {\n                ...\n              });\n      - pattern-either:\n          - pattern-inside: |\n              const $USER = req.body.$FIELD;\n              ...\n          - pattern-inside: |\n              const $USER = req.query.$FIELD;\n              ...\n          - pattern-inside: |\n              const $USER = req.params.$FIELD;\n              ...\n          - pattern-inside: |\n              let $USER = req.body.$FIELD;\n              ...\n          - pattern-inside: |\n              let $USER = req.query.$FIELD;\n              ...\n          - pattern-inside: |\n              let $USER = req.params.$FIELD;\n              ...\n    pattern-not:\n      # Excluir casos donde se usa execFile/execFileSync/spawn con argumentos separados\n      - pattern: |\n          $CP.execFile($BIN, $ARGS, ...);\n      - pattern: |\n          $CP.spawn($BIN, $ARGS, ...);"
  },
  {
    "id": "CVE-2025-58745",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558745\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible explotaci\u00f3n de CVE-2025-58745: carga de archivos Excel validando\n      \u00fanicamente el MIME type declarado por el cliente (`file.mimetype`) en\n      `multer.fileFilter`, sin validar extensi\u00f3n ni contenido real. Un atacante\n      puede subir un archivo malicioso (por ejemplo, un webshell `.php`) con\n      magic bytes y/o cabeceras manipuladas para que parezca un Excel y quede\n      accesible o ejecutable en el servidor.\n    metadata:\n      cve: \"CVE-2025-58745\"\n      source: \"CISA_KEV\"\n      category: \"file-upload\"\n      likelihood: \"high\"\n      impact: \"high\"\n      confidence: \"medium\"\n    patterns:\n      - pattern-inside: |\n          const $MULTER = require('multer');\n          ...\n      - pattern-inside: |\n          const $STORAGE = $MULTER.diskStorage({\n            ...\n          });\n      - pattern-inside: |\n          const $UPLOAD = $MULTER({\n            storage: $STORAGE,\n            fileFilter: ($REQ, $FILE, $CB) => {\n              ...\n            }\n          });\n      - pattern: |\n          fileFilter: ($REQ, $FILE, $CB) => {\n            const $ALLOWED = [...];\n            if ($ALLOWED.includes($FILE.mimetype)) {\n              return $CB(null, true);\n            }\n            return $CB(new Error(...));\n          }\n      - pattern-not: |\n          fileFilter: ($REQ, $FILE, $CB) => {\n            ...\n            if ($ALLOWED.includes($FILE.mimetype) && $FILE.originalname.endsWith('.xlsx')) {\n              return $CB(null, true);\n            }\n            ...\n          }"
  },
  {
    "id": "CVE-2025-58453",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558453\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-58453): se construye din\u00e1micamente una consulta SQL\n      concatenando directamente datos controlados por el usuario (por ejemplo, req.query.id_anexo)\n      en la cl\u00e1usula WHERE antes de pasarlos a db.query. Un atacante puede manipular el par\u00e1metro\n      para alterar la consulta, extraer o modificar datos sensibles, o da\u00f1ar la base de datos.\n      Usa consultas parametrizadas/preparadas (placeholders) en lugar de concatenaci\u00f3n de strings.\n    metadata:\n      cve: \"CVE-2025-58453\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql2\"]\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      vulnerability_class: [\"SQL Injection\"]\n    patterns:\n      - pattern-either:\n          # Caso t\u00edpico: template string con interpolaci\u00f3n de variable controlada\n          - pattern: |\n              $DB.$QUERY_FN(`... = ${$USER_INPUT}...`, ...)\n          # Concatenaci\u00f3n con +\n          - pattern: |\n              $DB.$QUERY_FN(\"...\" + $USER_INPUT + \"...\", ...)\n          - pattern: |\n              $DB.$QUERY_FN('...' + $USER_INPUT + '...', ...)\n      - pattern-inside: |\n          const $APP = require('express');\n          ...\n          $APP.$METHOD($ROUTE, ($REQ, $RES, ...$REST) => {\n            ...\n            $USER_INPUT = $REQ.$PROP.$KEY;\n            ...\n          });\n      - pattern-inside: |\n          const $DB = require('mysql2').createConnection(...);\n          ...\n      - pattern-inside: |\n          $DB.$QUERY_FN($SQL, ...);\n      - pattern-not: |\n          $DB.$QUERY_FN($SQL, [$USER_INPUT, ...], ...);\n      - pattern-not: |\n          $DB.$QUERY_FN($SQL, { ... }, ...);"
  },
  {
    "id": "CVE-2025-48208",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202548208\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible LDAP Injection (CVE-2025-48208): se construye un filtro LDAP concatenando\n      directamente datos controlados por el usuario (por ejemplo, `req.body.filter`) en\n      la cadena de b\u00fasqueda (`opts.filter` o par\u00e1metro `filter` de `client.search`).\n      Un atacante autenticado puede inyectar operadores LDAP especiales (`*`, `)`, `(|`, etc.)\n      para alterar la consulta, eludir controles de acceso o extraer informaci\u00f3n sensible.\n      Valida y escapa los valores de entrada antes de construir filtros LDAP o utiliza\n      APIs que manejen par\u00e1metros de forma segura.\n    metadata:\n      cve: CVE-2025-48208\n      source: CISA_KEV\n      category: security\n      technology: [nodejs, express, ldapjs]\n      cwe: \"CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')\"\n    patterns:\n      - pattern-either:\n          # Caso 1: filtro se pasa directamente como string concatenado al par\u00e1metro filter de client.search\n          - pattern: |\n              $CLIENT.search($BASE_DN, { ..., filter: $FILTER, ... }, ...);\n          # Caso 2: filtro se pasa como segundo argumento (forma abreviada) a client.search\n          - pattern: |\n              $CLIENT.search($BASE_DN, $FILTER, ...);\n      - pattern-inside: |\n          $CLIENT = require('ldapjs');\n          ...\n      - pattern-inside: |\n          const $APP = require('express')();\n          ...\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ..., (req, res, ... ) => {\n            ...\n          });\n      - pattern-either:\n          # Filtro construido con template string que incluye datos de req.*\n          - pattern: |\n              $FILTER = `...${req.$SRC}...`;\n          - pattern: |\n              $FILTER = `...${req.$SRC.$FIELD}...`;\n          # Filtro construido con concatenaci\u00f3n de strings que incluye datos de req.*\n          - pattern: |\n              $FILTER = \"...\"+req.$SRC+\"...\";\n          - pattern: |\n              $FILTER = \"...\"+req.$SRC.$FIELD+\"...\";\n          - pattern: |\n              $FILTER = req.$SRC + \"...\";\n          - pattern: |\n              $FILTER = req.$SRC.$FIELD + \"...\";\n      - metavariable-pattern:\n          metavariable: $SRC\n          pattern: |\n            body\n      - pattern-not: |\n          $FILTER = $SANITIZE(...);\n      - pattern-not: |\n          $FILTER = $SANITIZE(req.$SRC);\n      - pattern-not: |\n          $FILTER = $SANITIZE(req.$SRC.$FIELD);"
  },
  {
    "id": "CVE-2025-58454",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558454\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-58454): se construye din\u00e1micamente una\n      consulta SQL con datos controlados por el usuario (por ejemplo, req.query.id_memorando)\n      mediante concatenaci\u00f3n/interpolaci\u00f3n de strings antes de pasarlos a mysql2.connection.query().\n      Un atacante puede manipular el par\u00e1metro para alterar la consulta SQL, extraer o modificar datos.\n      Usa consultas parametrizadas/preparadas en lugar de interpolar directamente los valores.\n    metadata:\n      cve: \"CVE-2025-58454\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql2\"]\n      likelihood: \"HIGH\"\n      impact: \"HIGH\"\n      confidence: \"MEDIUM\"\n    patterns:\n      - pattern-inside: |\n          const express = require('express');\n          ...\n      - pattern-inside: |\n          $APP = express();\n          ...\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          });\n      - pattern-inside: |\n          $ID = $REQ.query.id_memorando;\n          ...\n      - pattern: |\n          $SQL = `SELECT * FROM $TABLE WHERE id_memorando = ${$ID}`;\n      - pattern-either:\n          - pattern: |\n              $CONN.query($SQL, ...);\n          - pattern: |\n              $CONN.query($SQL, ($ERR, $RESULTS) => {\n                ...\n              });\n    fix: >\n      Usa consultas parametrizadas, por ejemplo:\n      const sql = 'SELECT * FROM despachos WHERE id_memorando = ?';\n      connection.query(sql, [idMemorando], ...);"
  },
  {
    "id": "CVE-2025-58445",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202558445\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Exposici\u00f3n de metadatos internos de compilaci\u00f3n y versi\u00f3n a trav\u00e9s de un endpoint p\u00fablico.\n      Esta pr\u00e1ctica facilita el fingerprinting de la aplicaci\u00f3n (nombre del servicio, versi\u00f3n exacta,\n      hash de commit, fecha de build, versi\u00f3n de runtime, SO/arquitectura y dependencias), lo que\n      puede ser aprovechado por un atacante para seleccionar exploits espec\u00edficos o preparar ataques\n      dirigidos (CVE-2025-58445). Limita la informaci\u00f3n expuesta en endpoints de salud/estado a lo\n      estrictamente necesario para monitoreo.\n    patterns:\n      - pattern-either:\n          # Caso 1: objeto buildInfo (o similar) con metadatos internos\n          - pattern: |\n              const $BUILDINFO = {\n                ...\n              };\n          # Caso 2: endpoint Express que expone buildInfo/metadata detallada v\u00eda res.json\n          - pattern: |\n              $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n                ...\n                $RES.json({\n                  ...,\n                  $KEY: $BUILDINFO,\n                  ...\n                });\n              });\n      - pattern-inside: |\n          const $APP = require('express')();\n          ...\n      - pattern-inside: |\n          $APP.$METHOD($ROUTE, ($REQ, $RES) => {\n            ...\n          });\n      - metavariable-pattern:\n          metavariable: $ROUTE\n          pattern: |\n            '/status'\n    metadata:\n      cve: CVE-2025-58445\n      source: CISA_KEV\n      category: security\n      technology:\n        - express\n      references:\n        - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-58445\n      description: >\n        Detecci\u00f3n de endpoints de estado/health en aplicaciones Express que exponen metadatos\n        internos de build y versi\u00f3n (buildInfo) de forma p\u00fablica, facilitando el fingerprinting\n        y la selecci\u00f3n de exploits dirigidos."
  },
  {
    "id": "CVE-2025-9941",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve20259941\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible carga de archivos insegura asociada a CVE-2025-9941: se usa\n      `multer.diskStorage` para guardar archivos subidos en un directorio\n      accesible p\u00fablicamente usando `file.originalname` como nombre final,\n      sin validaci\u00f3n de tipo, tama\u00f1o o extensi\u00f3n. Un atacante puede subir\n      archivos maliciosos (por ejemplo, scripts ejecutables) y acceder a\n      ellos directamente v\u00eda HTTP, lo que puede derivar en ejecuci\u00f3n de\n      c\u00f3digo, defacement o exfiltraci\u00f3n de datos. Valida estrictamente el\n      tipo de archivo, tama\u00f1o, extensi\u00f3n y evita usar el nombre original\n      del archivo en rutas p\u00fablicas.\n    metadata:\n      cve: \"CVE-2025-9941\"\n      source: \"CISA_KEV\"\n      category: security\n      technology:\n        - express\n        - nodejs\n        - multer\n    patterns:\n      - pattern-either:\n          # Patr\u00f3n 1: configuraci\u00f3n de diskStorage con destino en carpeta p\u00fablica y uso de originalname\n          - pattern: |\n              const $M = require('multer');\n              ...\n              const $STORAGE = $M.diskStorage({\n                destination: function ($REQ, $FILE, $CB) {\n                  $CB(null, $DEST);\n                },\n                filename: function ($REQ2, $FILE2, $CB2) {\n                  $CB2(null, $FILE2.originalname);\n                }\n              });\n          # Patr\u00f3n 2: uso de multer.diskStorage con filename basado en originalname (forma m\u00e1s gen\u00e9rica)\n          - pattern: |\n              $MULTER.diskStorage({\n                ...\n                filename: function ($REQ, $FILE, $CB) {\n                  $CB(..., $FILE.originalname);\n                }\n              })\n      # Debe existir un uso de `upload.single(...)` o similar en una ruta Express (indica endpoint de subida)\n      - pattern-either:\n          - pattern: |\n              $APP.post($ROUTE, $UPLOAD.single($FIELD), ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $APP.post($ROUTE, $UPLOAD.single($FIELD), function ($REQ, $RES) {\n                ...\n              })\n          - pattern: |\n              $APP.$METHOD($ROUTE, $UPLOAD.single($FIELD), ($REQ, $RES) => {\n                ...\n              })\n          - pattern: |\n              $APP.$METHOD($ROUTE, $UPLOAD.single($FIELD), function ($REQ, $RES) {\n                ...\n              })\n    fix: >\n      No uses `file.originalname` directamente como nombre final ni guardes\n      archivos subidos en rutas p\u00fablicas sin validaci\u00f3n. Genera nombres\n      aleatorios seguros, aplica filtros de tipo MIME/extensi\u00f3n, l\u00edmites de\n      tama\u00f1o y, si es posible, almacena los archivos fuera del \u00e1rbol\n      p\u00fablico de la aplicaci\u00f3n."
  },
  {
    "id": "CVE-2025-10012",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202510012\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-10012-like): se construye din\u00e1micamente\n      una consulta SQL concatenando directamente datos controlados por el\n      usuario (por ejemplo, req.query.ref_cod_aluno) en la cadena de consulta\n      antes de pasarlos a db.query(). Un atacante puede manipular el par\u00e1metro\n      para alterar la consulta SQL, extraer o modificar datos sensibles o\n      comprometer la base de datos. Use consultas parametrizadas/preparadas\n      (placeholders) en lugar de concatenaci\u00f3n de strings.\n    metadata:\n      cve: \"CVE-2025-10012\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql2\"]\n      vulnerability: \"sql-injection\"\n    patterns:\n      - pattern-either:\n          # Caso 1: template string con interpolaci\u00f3n de variable controlada\n          - pattern: |\n              $DB.$QUERY_FN(`... = ${$USER_INPUT} ...`, ...)\n          # Caso 2: concatenaci\u00f3n cl\u00e1sica con +\n          - pattern: |\n              $DB.$QUERY_FN(\"...\" + $USER_INPUT + \"...\", ...)\n      - pattern-inside: |\n          app.$ROUTE_METHOD($ROUTE, ($REQ, $RES, ...) => {\n            ...\n          })\n      - pattern-inside: |\n          const $USER_INPUT = $REQ.query.$PARAM;\n      - pattern-inside: |\n          const $DB = require('mysql2').createConnection(...);\n      - metavariable-regex:\n          metavariable: $QUERY_FN\n          regex: ^(query|execute|executeQuery|raw|run)$\n      - metavariable-regex:\n          metavariable: $ROUTE_METHOD\n          regex: ^(get|post|put|delete|patch|all|use)$"
  },
  {
    "id": "CVE-2025-10098",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-cve202510098\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible SQL Injection (CVE-2025-10098): se construye din\u00e1micamente una\n      consulta SQL concatenando o interpolando datos controlados por el usuario\n      (por ejemplo, par\u00e1metros de `req.body`, `req.query` o similares) en la\n      cadena de consulta pasada a `db.query`/`connection.query` de `mysql`. Un\n      atacante puede manipular estos valores para alterar la consulta SQL,\n      exfiltrar datos o escalar privilegios. Usa consultas parametrizadas\n      (placeholders `?` o bindings) en lugar de concatenar/interpolar valores\n      directamente en la cadena SQL.\n    metadata:\n      cve: \"CVE-2025-10098\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"mysql\"]\n      vulnerability: \"sql-injection\"\n    patterns:\n      - pattern-either:\n          # mysql / mysql2 style: db.query(sql, ...)\n          - pattern: |\n              $DB.query($SQL, ...);\n          # connection.query(sql, ...)\n          - pattern: |\n              $CONN.query($SQL, ...);\n      - pattern-either:\n          # SQL construido con template literal que incluye valores no constantes\n          - pattern: |\n              const $SQL = `$X${...}$Y`;\n          - pattern: |\n              let $SQL = `$X${...}$Y`;\n          - pattern: |\n              var $SQL = `$X${...}$Y`;\n          # SQL construido por concatenaci\u00f3n con +\n          - pattern: |\n              const $SQL = $X + $Y;\n          - pattern: |\n              let $SQL = $X + $Y;\n          - pattern: |\n              var $SQL = $X + $Y;\n      - pattern-either:\n          # Origen t\u00edpico de datos controlados por el usuario en Express\n          - pattern: |\n              $SRC = $REQ.body.$FIELD;\n          - pattern: |\n              $SRC = $REQ.query.$FIELD;\n          - pattern: |\n              $SRC = $REQ.params.$FIELD;\n          - pattern: |\n              $SRC = $REQ.headers[$H];\n      - pattern-either:\n          # El valor controlado por el usuario se usa en la construcci\u00f3n del SQL\n          - pattern: |\n              const $SQL = ... $SRC ...;\n          - pattern: |\n              let $SQL = ... $SRC ...;\n          - pattern: |\n              var $SQL = ... $SRC ...;\n          - pattern: |\n              $SQL = ... $SRC ...;\n      - pattern-not: |\n          // Exclusi\u00f3n b\u00e1sica de consultas parametrizadas con placeholders\n          $DB.query($SQL, [...]);\n      - pattern-not: |\n          // Exclusi\u00f3n b\u00e1sica de consultas parametrizadas con objeto de par\u00e1metros\n          $DB.query($SQL, {...});\n    fix: >\n      Usa consultas parametrizadas. Por ejemplo:\n      `const sql = \"UPDATE users SET full_name = ?, email = ? WHERE id = ?\"; db.query(sql, [fullName, email, uid]);`"
  },
  {
    "id": "16c86189-b556-4ee8-b4c7-7e350a195a4f",
    "reason": "La regla no detect\u00f3 el c\u00f3digo vulnerable (False Negative).",
    "attempts": 3,
    "failed_rule": "rules:\n  - id: synthetic-16c86189b5564ee8b4c77e350a195a4f\n    languages: [javascript, typescript]\n    severity: ERROR\n    message: >\n      Posible Server-Side Template Injection (SSTI) en motor Velocity. Se est\u00e1\n      construyendo y renderizando una plantilla Velocity a partir de input\n      controlado por el usuario y se exponen directamente los errores del\n      motor (por ejemplo, ParseErrorException, VelocityException,\n      TemplateInitException). Este patr\u00f3n es consistente con explotaci\u00f3n\n      remota similar a la descrita en el CVE 16c86189-b556-4ee8-b4c7-7e350a195a4f,\n      donde la inyecci\u00f3n de expresiones en plantillas puede conducir a\n      ejecuci\u00f3n remota de c\u00f3digo (RCE) cuando el motor de plantillas eval\u00faa\n      din\u00e1micamente el contenido proporcionado por el atacante.\n    metadata:\n      cve: \"16c86189-b556-4ee8-b4c7-7e350a195a4f\"\n      source: \"CISA_KEV\"\n      category: \"security\"\n      technology: [\"nodejs\", \"express\", \"velocity\"]\n      attack:\n        - \"attack.initial-access\"\n        - \"attack.t1190\"\n      likelihood: \"high\"\n      impact: \"high\"\n      vulnerability_class: [\"SSTI\", \"RCE\"]\n    patterns:\n      - pattern-either:\n          # 1) Funci\u00f3n que envuelve spawn/java -jar ... velocity-renderer.jar\n          - pattern: |\n              function $FUNC($TEMPLATE, $DATA, ...$REST) {\n                ...\n                const $CHILD = spawn('java', ['-jar', $JAR, $TEMPLATE, JSON.stringify($DATA), ...$ARGS]);\n                ...\n                $CHILD.stderr.on('data', ($CHUNK) => {\n                  $ERR_OUTPUT += $CHUNK.toString();\n                });\n                ...\n                $CHILD.on('close', ($CODE) => {\n                  if ($CODE !== 0) {\n                    console.error('Velocity error:', $ERR_OUTPUT);\n                    return $CB(new Error('VelocityException: ' + $ERR_OUTPUT));\n                  }\n                  $CB(null, $OUTPUT);\n                });\n              }\n          # Variante m\u00e1s gen\u00e9rica: cualquier java -jar con templateString y JSON.stringify(data)\n          - pattern: |\n              function $FUNC($TEMPLATE, $DATA, ...$REST) {\n                ...\n                const $CHILD = spawn('java', ['-jar', $JAR, $TEMPLATE, JSON.stringify($DATA), ...$ARGS]);\n                ...\n                $CHILD.stderr.on('data', ($CHUNK) => {\n                  $ERR_OUTPUT += $CHUNK.toString();\n                });\n                ...\n                $CHILD.on('close', ($CODE) => {\n                  if ($CODE !== 0) {\n                    console.error(...);\n                    return $CB(new Error(...$ERR_OUTPUT...));\n                  }\n                  $CB(null, $OUTPUT);\n                });\n              }\n      - pattern-either:\n          # 2) Ruta Express que pasa input directo del body como plantilla al renderer inseguro\n          - pattern: |\n              app.$METHOD($ROUTE, (req, res) => {\n                ...\n                const $USER_TEMPLATE = req.body.$FIELD;\n                ...\n                $FUNC($USER_TEMPLATE, $DATA, ($ERR, $HTML) => {\n                  if ($ERR) {\n                    return res.status(500).send(...$ERR.message...);\n                  }\n                  res.send($HTML);\n                });\n              });\n          - pattern: |\n              $APP.$METHOD($ROUTE, (req, res) => {\n                ...\n                const $USER_TEMPLATE = req.body.$FIELD;\n                ...\n                $RENDER($USER_TEMPLATE, $DATA, ($ERR, $OUT) => {\n                  if ($ERR) {\n                    res.status(500).send(...$ERR.message...);\n                    return;\n                  }\n                  res.send($OUT);\n                });\n              });\n      - pattern-inside: |\n          const { spawn } = require('child_process');\n          ...\n    fix: >\n      Evita pasar directamente al motor Velocity plantillas controladas por el\n      usuario. Usa plantillas est\u00e1ticas predefinidas, aplica una lista blanca\n      estricta de tokens permitidos o un lenguaje de plantillas seguro que no\n      permita ejecuci\u00f3n arbitraria. No devuelvas al cliente los mensajes de\n      error completos del motor de plantillas; registra los detalles solo en\n      el servidor y muestra mensajes gen\u00e9ricos al usuario."
  }
]