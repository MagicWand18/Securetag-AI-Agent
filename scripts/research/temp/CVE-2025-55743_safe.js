const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');
const fileType = require('file-type'); // npm install file-type

const app = express();

// Carpeta para avatares, idealmente fuera de la raíz pública o servida de forma controlada
const uploadDir = path.join(__dirname, 'uploads', 'avatars');
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

// Lista blanca de tipos de imagen permitidos
const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
const MAX_FILE_SIZE = 2 * 1024 * 1024; // 2 MB

// Almacenamiento temporal en memoria para poder inspeccionar el contenido real
const storage = multer.memoryStorage();

const upload = multer({
  storage,
  limits: {
    fileSize: MAX_FILE_SIZE
  }
});

// Función auxiliar para guardar el archivo de forma segura tras validarlo
async function saveValidatedImage(buffer, originalName) {
  // Detectar tipo real del archivo a partir del contenido
  const detected = await fileType.fromBuffer(buffer);

  if (!detected || !ALLOWED_MIME_TYPES.includes(detected.mime)) {
    throw new Error('Tipo de archivo no permitido');
  }

  // Generar nombre de archivo seguro (no confiar en originalname)
  const safeName = crypto.randomBytes(16).toString('hex');
  const ext = '.' + (detected.ext || 'bin');
  const finalName = safeName + ext;
  const finalPath = path.join(uploadDir, finalName);

  // Guardar el archivo en disco
  await fs.promises.writeFile(finalPath, buffer);

  // Devolver solo un identificador o ruta controlada (no permitir rutas arbitrarias)
  return {
    filename: finalName,
    path: finalPath,
    mime: detected.mime
  };
}

// Ruta segura de creación de usuario con subida de imagen de perfil
app.post('/users', upload.single('avatar'), async (req, res) => {
  try {
    const { username, email } = req.body;

    if (!req.file) {
      return res.status(400).json({ error: 'Falta el archivo avatar' });
    }

    // Validación en servidor: inspeccionar el contenido real del archivo
    const saved = await saveValidatedImage(req.file.buffer, req.file.originalname);

    // Aquí se podría guardar el usuario en BD junto con el nombre del archivo
    // (omitido por simplicidad)

    // No exponer directamente el path físico; usar una ruta controlada
    res.json({
      message: 'Usuario creado (seguro): avatar validado en servidor',
      avatarId: saved.filename
    });
  } catch (err) {
    console.error('Error al procesar avatar:', err.message);
    res.status(400).json({ error: 'Archivo inválido o error al procesar la imagen' });
  }
});

// Ejemplo de endpoint controlado para servir avatares
// (en producción, añadir autenticación/autorización según el caso)
app.get('/avatars/:id', async (req, res) => {
  try {
    const fileName = req.params.id;

    // Validar formato del nombre (solo hex + extensión simple)
    if (!/^[a-f0-9]{32}\.[a-z0-9]+$/i.test(fileName)) {
      return res.status(400).send('Identificador de avatar inválido');
    }

    const filePath = path.join(uploadDir, fileName);

    if (!fs.existsSync(filePath)) {
      return res.status(404).send('Avatar no encontrado');
    }

    // Opcional: volver a detectar tipo para cabecera Content-Type
    const buffer = await fs.promises.readFile(filePath);
    const detected = await fileType.fromBuffer(buffer);
    const mime = detected && ALLOWED_MIME_TYPES.includes(detected.mime)
      ? detected.mime
      : 'application/octet-stream';

    res.setHeader('Content-Type', mime);
    res.send(buffer);
  } catch (err) {
    console.error('Error al servir avatar:', err.message);
    res.status(500).send('Error interno');
  }
});

app.listen(3001, () => {
  console.log('Servidor seguro escuchando en http://localhost:3001');
});
