const express = require('express');
const bodyParser = require('body-parser');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const multer = require('multer');

// Configuración global de la aplicación (con campos explícitos)
let appConfig = {
  allowRegistrations: false,
  uploadDir: path.join(__dirname, 'uploads'),
  adminEmail: 'admin@example.com'
};

// Lista blanca de claves de configuración modificables
const ALLOWED_CONFIG_KEYS = new Set(['allowRegistrations', 'adminEmail']);

// Simulación de almacenamiento de usuarios (en memoria)
const users = [
  // Usuario administrador preconfigurado
  { id: 1, username: 'admin', password: 'admin123', role: 'admin', token: null }
];

// Genera un token de sesión simple (para ejemplo)
function generateToken() {
  return crypto.randomBytes(32).toString('hex');
}

// Middleware de autenticación por token (ejemplo simplificado)
function authMiddleware(req, res, next) {
  const token = req.headers['x-auth-token'];
  if (!token) {
    return res.status(401).json({ error: 'Authentication required' });
  }

  const user = users.find(u => u.token === token);
  if (!user) {
    return res.status(401).json({ error: 'Invalid token' });
  }

  req.user = user;
  next();
}

// Middleware de autorización (solo admin)
function adminOnly(req, res, next) {
  if (!req.user || req.user.role !== 'admin') {
    return res.status(403).json({ error: 'Admin privileges required' });
  }
  next();
}

const app = express();
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Endpoint de login para obtener un token (ejemplo simplificado)
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  const user = users.find(u => u.username === username && u.password === password);

  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  user.token = generateToken();
  res.json({ token: user.token });
});

// SEGURO: endpoint de configuración protegido por autenticación y autorización
// Solo un administrador autenticado puede modificar opciones específicas
app.post('/options', authMiddleware, adminOnly, (req, res) => {
  const newOptions = req.body || {};

  // Construir un objeto de actualización solo con claves permitidas y tipos esperados
  const updatedConfig = { ...appConfig };

  for (const [key, value] of Object.entries(newOptions)) {
    if (!ALLOWED_CONFIG_KEYS.has(key)) {
      // Ignorar claves no permitidas
      continue;
    }

    // Validaciones básicas de tipo/valor
    if (key === 'allowRegistrations') {
      if (typeof value !== 'boolean') continue;
      updatedConfig.allowRegistrations = value;
    }

    if (key === 'adminEmail') {
      if (typeof value !== 'string' || !value.includes('@')) continue;
      updatedConfig.adminEmail = value;
    }
  }

  appConfig = updatedConfig;

  // Persistencia segura de la configuración (solo campos esperados)
  fs.writeFileSync(
    path.join(__dirname, 'config.json'),
    JSON.stringify(appConfig, null, 2),
    'utf8'
  );

  res.json({
    status: 'ok',
    message: 'Configuration updated securely',
    config: appConfig
  });
});

// Endpoint de registro que respeta la configuración pero no es modificable por usuarios anónimos
app.post('/register', (req, res) => {
  if (!appConfig.allowRegistrations) {
    return res.status(403).json({ error: 'Registrations are disabled' });
  }

  const { username, password } = req.body;
  if (!username || !password) {
    return res.status(400).json({ error: 'Username and password are required' });
  }

  if (users.some(u => u.username === username)) {
    return res.status(409).json({ error: 'User already exists' });
  }

  const newUser = {
    id: users.length + 1,
    username,
    password,
    role: 'user',
    token: null
  };

  users.push(newUser);
  res.json({ status: 'user_created', username: newUser.username });
});

// Configuración de subida de archivos con directorio fijo y validación de tipo
const UPLOAD_DIR = path.join(__dirname, 'uploads');

if (!fs.existsSync(UPLOAD_DIR)) {
  fs.mkdirSync(UPLOAD_DIR, { recursive: true });
}

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, UPLOAD_DIR); // No se permite cambiar este valor vía /options
  },
  filename: (req, file, cb) => {
    // Evitar sobrescritura directa usando nombre original
    const safeName = Date.now() + '-' + file.originalname.replace(/[^a-zA-Z0-9.\-_]/g, '');
    cb(null, safeName);
  }
});

const upload = multer({
  storage,
  fileFilter: (req, file, cb) => {
    // Ejemplo: solo permitir imágenes (evita subir webshells .php, .js, etc.)
    if (!file.mimetype.startsWith('image/')) {
      return cb(new Error('Only image uploads are allowed'));
    }
    cb(null, true);
  },
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB
  }
});

// Endpoint de subida protegido opcionalmente (ejemplo: requiere autenticación)
app.post('/upload', authMiddleware, upload.single('file'), (req, res) => {
  res.json({ status: 'file_uploaded', file: req.file.filename });
});

app.listen(3001, () => {
  console.log('Secure app listening on port 3001');
});
