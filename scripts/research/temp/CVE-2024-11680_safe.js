const express = require('express');
const bodyParser = require('body-parser');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// Configuración global de la aplicación (solo modificable por admin autenticado)
let appConfig = {
  allowRegistrations: false,
  uploadDir: path.join(__dirname, 'uploads'),
  adminEmail: 'admin@example.com'
};

// Configuración de "admin" muy simplificada para el ejemplo
const ADMIN_USER = 'admin';
const ADMIN_PASSWORD_HASH = crypto
  .createHash('sha256')
  .update('SuperSecretPassword')
  .digest('hex');

// Token de sesión en memoria (solo para ejemplo)
let adminSessionToken = null;

const app = express();
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Middleware de autenticación de administrador
function requireAdmin(req, res, next) {
  const token = req.headers['x-admin-token'];
  if (!token || token !== adminSessionToken) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  next();
}

// Login de administrador para obtener un token
app.post('/admin/login', (req, res) => {
  const { username, password } = req.body;
  const hash = crypto.createHash('sha256').update(password || '').digest('hex');

  if (username === ADMIN_USER && hash === ADMIN_PASSWORD_HASH) {
    adminSessionToken = crypto.randomBytes(32).toString('hex');
    return res.json({ token: adminSessionToken });
  }

  res.status(401).json({ error: 'Invalid credentials' });
});

// Validación estricta de campos de configuración permitidos
function validateConfigUpdate(payload) {
  const allowedKeys = ['allowRegistrations', 'adminEmail'];
  const newConfig = {};

  for (const key of Object.keys(payload)) {
    if (!allowedKeys.includes(key)) {
      throw new Error(`Config key not allowed: ${key}`);
    }

    if (key === 'allowRegistrations') {
      if (typeof payload[key] !== 'boolean') {
        throw new Error('allowRegistrations must be boolean');
      }
      newConfig.allowRegistrations = payload[key];
    }

    if (key === 'adminEmail') {
      if (typeof payload[key] !== 'string' || !payload[key].includes('@')) {
        throw new Error('adminEmail must be a valid email');
      }
      newConfig.adminEmail = payload[key];
    }
  }

  return newConfig;
}

// SEGURO: endpoint de configuración protegido y validado
app.post('/options', requireAdmin, (req, res) => {
  try {
    const validatedConfig = validateConfigUpdate(req.body);

    // Solo se actualizan campos permitidos
    Object.assign(appConfig, validatedConfig);

    // Persistir configuración de forma segura
    fs.writeFileSync(
      path.join(__dirname, 'config.json'),
      JSON.stringify(appConfig, null, 2),
      { mode: 0o600 }
    );

    res.json({
      status: 'ok',
      message: 'Configuration updated securely',
      config: appConfig
    });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// Registro de usuarios controlado por configuración
app.post('/register', (req, res) => {
  if (!appConfig.allowRegistrations) {
    return res.status(403).json({ error: 'Registrations are disabled' });
  }

  const { username, password } = req.body;
  if (!username || !password) {
    return res.status(400).json({ error: 'username and password are required' });
  }

  // Simulación: guardar usuario en un archivo de texto
  fs.appendFileSync(
    path.join(__dirname, 'users.txt'),
    `${username}:${password}\n`,
    { mode: 0o600 }
  );

  res.json({ status: 'user_created', username });
});

// Subida de archivos con ruta fija y validación básica del nombre
const SAFE_UPLOAD_DIR = path.join(__dirname, 'uploads');
if (!fs.existsSync(SAFE_UPLOAD_DIR)) {
  fs.mkdirSync(SAFE_UPLOAD_DIR, { recursive: true, mode: 0o700 });
}

app.post('/upload', (req, res) => {
  const { filename, contentBase64 } = req.body;

  if (!filename || !contentBase64) {
    return res.status(400).json({ error: 'filename and contentBase64 are required' });
  }

  // Evitar traversal y limitar extensión
  const safeName = path.basename(filename).replace(/[^a-zA-Z0-9._-]/g, '_');
  const ext = path.extname(safeName).toLowerCase();
  const allowedExts = ['.txt', '.pdf', '.jpg', '.png'];

  if (!allowedExts.includes(ext)) {
    return res.status(400).json({ error: 'File type not allowed' });
  }

  const filePath = path.join(SAFE_UPLOAD_DIR, safeName);
  const buffer = Buffer.from(contentBase64, 'base64');
  fs.writeFileSync(filePath, buffer, { mode: 0o600 });

  res.json({ status: 'file_uploaded', path: `/files/${safeName}` });
});

// Servir estáticos solo desde el directorio seguro
app.use('/files', express.static(SAFE_UPLOAD_DIR, {
  fallthrough: false,
  dotfiles: 'deny'
}));

app.listen(3000, () => {
  console.log('Secure app listening on port 3000');
});
