const express = require('express');
const crypto = require('crypto');

// Versión segura: uso de cifrado fuerte (AES-256-GCM), IV aleatorio y clave robusta
// Mantiene la misma funcionalidad (emitir y validar un "token" basado en userId)

const app = express();
app.use(express.json());

// Clave fuerte de 32 bytes, idealmente cargada desde una variable de entorno segura
const STRONG_KEY = crypto.createHash('sha256')
  .update(process.env.APP_SECRET || 'cambia-esta-clave-en-produccion')
  .digest(); // 32 bytes

const STRONG_ALGO = 'aes-256-gcm';

function encryptParamStrong(param) {
  const iv = crypto.randomBytes(12); // IV aleatorio recomendado para GCM
  const cipher = crypto.createCipheriv(STRONG_ALGO, STRONG_KEY, iv);

  let encrypted = cipher.update(param, 'utf8', 'base64');
  encrypted += cipher.final('base64');

  const authTag = cipher.getAuthTag();

  // Empaquetamos iv + authTag + ciphertext en un solo string seguro
  const payload = Buffer.concat([iv, authTag, Buffer.from(encrypted, 'base64')]).toString('base64');
  return payload;
}

function decryptParamStrong(payload) {
  const data = Buffer.from(payload, 'base64');

  const iv = data.subarray(0, 12);
  const authTag = data.subarray(12, 28); // 16 bytes
  const ciphertext = data.subarray(28);

  const decipher = crypto.createDecipheriv(STRONG_ALGO, STRONG_KEY, iv);
  decipher.setAuthTag(authTag);

  let decrypted = decipher.update(ciphertext, undefined, 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

app.post('/api/secure-token', (req, res) => {
  const userId = String(req.body.userId || 'guest');

  // Cifrado fuerte del parámetro de entrada
  const token = encryptParamStrong(userId);

  res.json({ token });
});

app.get('/api/secure-validate', (req, res) => {
  const token = req.query.token;
  if (!token) {
    return res.status(400).json({ error: 'Missing token' });
  }

  try {
    const userId = decryptParamStrong(token);

    // En un sistema real, se deberían aplicar controles adicionales:
    // - Expiración del token
    // - Firma/HMAC sobre claims estructurados (JWT u otro formato)
    // - Validación de permisos, etc.

    res.json({ ok: true, userId });
  } catch (e) {
    res.status(400).json({ error: 'Invalid or tampered token' });
  }
});

app.listen(3001, () => {
  console.log('Servidor seguro escuchando en http://localhost:3001');
});
