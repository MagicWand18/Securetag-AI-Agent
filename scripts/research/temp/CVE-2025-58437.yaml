rules:
  - id: synthetic-cve202558437
    languages: [javascript, typescript]
    severity: ERROR
    message: >
      Posible exposición y reutilización de tokens de sesión asociados a workspaces
      preconstruidos (prebuilds). El token de un usuario de sistema (por ejemplo
      "prebuilds-system-user") se genera de forma predecible, se persiste en
      plantillas/archivos (p.ej. Terraform) y no se invalida cuando el workspace
      es reclamado por otro usuario, permitiendo que un atacante que obtenga la
      plantilla use ese token para acceder al workspace. Esto es análogo a
      CVE-2025-58437, donde coder_workspace_owner.session_token queda expuesto
      en plantillas y sigue siendo válido tras el reclamo del workspace.
    metadata:
      cve: "CVE-2025-58437"
      source: "CISA_KEV"
      category: security
      technology:
        - express
        - nodejs
      references:
        - "https://semgrep.dev"
    patterns:
      # 1) Detectar un mapa/estructura de workspaces en memoria
      - pattern-either:
          - pattern: |
              const $WS = new Map(...);
          - pattern: |
              let $WS = new Map(...);
          - pattern: |
              var $WS = new Map(...);
      # 2) Detectar un endpoint que crea un prebuild con un usuario de sistema
      - pattern: |
          app.post('/prebuilds', ($REQ, $RES) => {
            ...
            const $WS_ID = `ws_${...}`;
            const $PREBUILD_USER = 'prebuilds-system-user';
            ...
            const $SESSION_TOKEN = $GEN_FUNC($PREBUILD_USER, $WS_ID);
            ...
            const $WS_OBJ = {
              id: $WS_ID,
              ownerUserId: $PREBUILD_USER,
              sessionToken: $SESSION_TOKEN,
              isPrebuilt: true,
              ...
            };
            ...
            $WS.set($WS_ID, $WS_OBJ);
            ...
            const $TEMPLATE_DATA = {
              workspace_id: $WS_ID,
              coder_workspace_owner: {
                id: $PREBUILD_USER,
                session_token: $SESSION_TOKEN
              }
            };
            ...
          });
      # 3) Detectar persistencia del token de sesión en disco (plantilla)
      - pattern-either:
          - pattern: |
              fs.writeFileSync(..., JSON.stringify($TEMPLATE_DATA, ...));
          - pattern: |
              fs.writeFile(..., JSON.stringify($TEMPLATE_DATA, ...), ...);
      # 4) Detectar endpoint de claim que cambia ownerUserId pero reutiliza el mismo workspace
      - pattern: |
          app.post('/workspaces/:id/claim', ($REQ2, $RES2) => {
            ...
            const $WORKSPACE_ID = $REQ2.params.id;
            const $USER_ID = $REQ2.body.userId;
            const $WS2 = $WS.get($WORKSPACE_ID);
            if (! $WS2 || ! $WS2.isPrebuilt) {
              return $RES2.status(404).json(...);
            }
            const $NEW_TOKEN = $GEN_FUNC($USER_ID, $WORKSPACE_ID);
            $WS2.ownerUserId = $USER_ID;
            $WS2.claimedBy = $USER_ID;
            $WS2.sessionToken = $NEW_TOKEN;
            $WS.set($WORKSPACE_ID, $WS2);
            ...
          });
      # 5) Detectar endpoint de acceso que solo compara el token almacenado
      - pattern: |
          app.get('/workspaces/:id', ($REQ3, $RES3) => {
            ...
            const $WORKSPACE_ID2 = $REQ3.params.id;
            const $TOKEN = $REQ3.headers['x-session-token'];
            const $WS3 = $WS.get($WORKSPACE_ID2);
            if (! $WS3) {
              return $RES3.status(404).json(...);
            }
            if ($TOKEN !== $WS3.sessionToken) {
              return $RES3.status(401).json(...);
            }
            $RES3.json(...);
          });