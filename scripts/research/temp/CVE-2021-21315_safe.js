const express = require('express');
const bodyParser = require('body-parser');
const path = require('path');

const app = express();
app.use(bodyParser.json());

// Implementación segura: sólo permite cargar plugins desde un directorio controlado
// y usando una lista blanca de nombres válidos. No se usa require directo con input.

// Directorio fijo donde residen los plugins legítimos
const PLUGINS_DIR = path.join(__dirname, 'plugins');

// Lista blanca de plugins permitidos (clave: nombre público, valor: archivo real)
const ALLOWED_PLUGINS = {
  'logger': 'logger.js',
  'reporter': 'reporter.js'
};

app.post('/run-plugin', (req, res) => {
  const { name, options } = req.body || {};

  // Validar que el nombre del plugin esté en la lista blanca
  if (!name || typeof name !== 'string' || !Object.prototype.hasOwnProperty.call(ALLOWED_PLUGINS, name)) {
    return res.status(400).json({ error: 'Plugin no permitido' });
  }

  try {
    // Resolver la ruta del plugin de forma segura, sin permitir path traversal
    const pluginFile = ALLOWED_PLUGINS[name];
    const pluginPath = path.join(PLUGINS_DIR, pluginFile);

    // Cargar el plugin desde un directorio controlado
    const plugin = require(pluginPath);

    if (typeof plugin.run !== 'function') {
      return res.status(400).json({ error: 'Plugin inválido' });
    }

    const result = plugin.run(options || {});
    res.json({ ok: true, result });
  } catch (err) {
    console.error('Error al cargar/ejecutar plugin:', err);
    res.status(500).json({ error: 'Error interno' });
  }
});

app.listen(3000, () => {
  console.log('Servidor seguro escuchando en http://localhost:3000');
});
