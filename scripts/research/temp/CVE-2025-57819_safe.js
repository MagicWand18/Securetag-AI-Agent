const express = require('express');
const mysql = require('mysql2/promise');
const helmet = require('helmet');
const crypto = require('crypto');
const app = express();

app.use(express.json());
app.use(helmet());

// Configuración de base de datos (ejemplo simplificado)
const pool = mysql.createPool({
  host: 'localhost',
  user: 'root',
  password: 'root',
  database: 'freepbx_like',
  connectionLimit: 10
});

// Middleware de autenticación fuerte basado en sesión/token
async function authMiddleware(req, res, next) {
  try {
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ ok: false, error: 'Authentication required' });
    }

    const token = authHeader.substring('Bearer '.length).trim();
    if (!token || token.length > 256) {
      return res.status(401).json({ ok: false, error: 'Invalid token' });
    }

    // Uso de consulta parametrizada para evitar SQL injection
    const [rows] = await pool.execute(
      'SELECT username, role FROM sessions JOIN users ON sessions.user_id = users.id WHERE sessions.token = ? AND sessions.expires_at > NOW()',
      [token]
    );

    if (rows.length === 0) {
      return res.status(401).json({ ok: false, error: 'Invalid or expired session' });
    }

    req.user = {
      username: rows[0].username,
      role: rows[0].role,
      authenticated: true
    };

    return next();
  } catch (err) {
    console.error('Auth error:', err);
    return res.status(500).json({ ok: false, error: 'Internal auth error' });
  }
}

// Middleware de autorización para administradores
function requireAdmin(req, res, next) {
  if (!req.user || !req.user.authenticated || req.user.role !== 'admin') {
    return res.status(403).json({ ok: false, error: 'Admin privileges required' });
  }
  return next();
}

// Ejemplo de login seguro para obtener un token (simplificado)
app.post('/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    if (typeof username !== 'string' || typeof password !== 'string') {
      return res.status(400).json({ ok: false, error: 'Invalid credentials format' });
    }

    // Consulta parametrizada
    const [rows] = await pool.execute(
      'SELECT id, username, password_hash, role FROM users WHERE username = ?',
      [username]
    );

    if (rows.length === 0) {
      return res.status(401).json({ ok: false, error: 'Invalid credentials' });
    }

    const user = rows[0];

    // Comparación de contraseña (aquí se asume bcrypt/argon2 en producción)
    const cryptoHash = crypto.createHash('sha256').update(password).digest('hex');
    if (cryptoHash !== user.password_hash) {
      return res.status(401).json({ ok: false, error: 'Invalid credentials' });
    }

    const token = crypto.randomBytes(32).toString('hex');

    await pool.execute(
      'INSERT INTO sessions (user_id, token, expires_at) VALUES (?, ?, DATE_ADD(NOW(), INTERVAL 1 HOUR))',
      [user.id, token]
    );

    return res.json({ ok: true, token });
  } catch (err) {
    console.error('Login error:', err);
    return res.status(500).json({ ok: false, error: 'Internal login error' });
  }
});

// Todas las rutas /admin requieren autenticación y rol admin
app.use('/admin', authMiddleware, requireAdmin);

// Ruta administrativa segura para operaciones de base de datos predefinidas
app.post('/admin/db/update-extension', async (req, res) => {
  try {
    const { extensionId, newCallerId } = req.body;

    if (!Number.isInteger(extensionId) || typeof newCallerId !== 'string' || newCallerId.length > 64) {
      return res.status(400).json({ ok: false, error: 'Invalid input' });
    }

    // Solo se permite una operación específica, con parámetros preparados
    const [result] = await pool.execute(
      'UPDATE extensions SET caller_id = ? WHERE id = ?',
      [newCallerId, extensionId]
    );

    return res.json({ ok: true, affectedRows: result.affectedRows });
  } catch (err) {
    console.error('DB update error:', err);
    return res.status(500).json({ ok: false, error: 'DB update error' });
  }
});

// Ruta administrativa segura para acciones de sistema controladas
app.post('/admin/system/reload-config', async (req, res) => {
  try {
    // En lugar de ejecutar comandos arbitrarios, se llama a una función interna controlada
    // que encapsula la lógica de recarga de configuración.

    // Simulación de recarga de configuración sin RCE
    const reloadConfig = async () => {
      // Aquí iría la lógica de recarga (p.ej. escribir archivos, enviar señales, etc.)
      return { reloaded: true, timestamp: new Date().toISOString() };
    };

    const result = await reloadConfig();
    return res.json({ ok: true, result });
  } catch (err) {
    console.error('System action error:', err);
    return res.status(500).json({ ok: false, error: 'System action error' });
  }
});

app.listen(3000, () => {
  console.log('Secure admin panel listening on port 3000');
});
