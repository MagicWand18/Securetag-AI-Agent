const express = require('express');
const fs = require('fs');
const path = require('path');
const http = require('http');

// Configuración "tipo Tautulli" simplificada
// PMS (Plex Media Server) controlado por el atacante
let pmsBaseUrl = 'http://attacker-controlled-pms.local:32400';

const app = express();

// Endpoint vulnerable similar a `pms_image_proxy`
// Permite al administrador (atacante) escribir archivos arbitrarios
app.get('/pms_image_proxy', (req, res) => {
  const imgUrl = req.query.img;        // URL de la imagen en el PMS controlado por el atacante
  const imgFormat = req.query.img_format; // Controlado por el atacante, se usa al final de la ruta de archivo

  if (!imgUrl || !imgFormat) {
    return res.status(400).send('Missing img or img_format');
  }

  // Metadatos simplificados (en Tautulli se usa un hash de metadatos + img_format)
  const meta = `${imgUrl}`;
  const hash = require('crypto').createHash('md5').update(meta).digest('hex');

  // VULNERABILIDAD: se concatena imgFormat sin sanitizar al final de la ruta
  // El atacante puede usar '../' para hacer path traversal y escribir donde quiera
  const imagesDir = path.join(__dirname, 'images_cache');
  const filePath = path.join(imagesDir, `${hash}_${imgFormat}`);

  // Si el archivo no existe, se descarga desde el PMS (controlado por el atacante)
  fs.access(filePath, fs.constants.F_OK, (err) => {
    if (!err) {
      // Ya existe, simplemente lo devolvemos
      return fs.createReadStream(filePath).pipe(res);
    }

    // Construimos la URL hacia el PMS (que el atacante controla)
    const pmsUrl = new URL(imgUrl, pmsBaseUrl);

    http.get(pmsUrl, (pmsRes) => {
      if (pmsRes.statusCode !== 200) {
        return res.status(502).send('Failed to fetch image from PMS');
      }

      // VULNERABILIDAD: escribimos el contenido recibido directamente en filePath
      // Si el atacante devuelve un script Python y ha usado path traversal en img_format,
      // puede escribir un archivo .py en una ubicación ejecutable por otro componente.
      const writeStream = fs.createWriteStream(filePath);
      pmsRes.pipe(writeStream);

      writeStream.on('finish', () => {
        // Devolvemos el archivo recién escrito
        fs.createReadStream(filePath).pipe(res);
      });

      writeStream.on('error', (e) => {
        res.status(500).send('Error writing file');
      });
    }).on('error', () => {
      res.status(502).send('Error contacting PMS');
    });
  });
});

// Ejemplo de "script notification agent" inseguro que ejecuta scripts locales
// combinando el file write anterior se obtiene RCE
app.post('/run_script', express.json(), (req, res) => {
  const scriptPath = req.body.script_path; // p.ej. ruta al .py escrito por el atacante

  // VULNERABILIDAD ADICIONAL: ejecución directa de un script arbitrario
  const { spawn } = require('child_process');
  const child = spawn('python3', [scriptPath]);

  let output = '';
  child.stdout.on('data', (data) => (output += data.toString()));
  child.stderr.on('data', (data) => (output += data.toString()));

  child.on('close', (code) => {
    res.json({ exitCode: code, output });
  });
});

app.listen(3000, () => {
  console.log('Vulnerable server listening on port 3000');
});
